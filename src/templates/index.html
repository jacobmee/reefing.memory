<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Line Chart Example</title>
    <link href="https://fonts.googleapis.com/css?family=Oswald:300,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body style="background: #f3f1f1; height: 100vh; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center;">
    <div style="width: 100%; min-height: 80vh; margin: 4px auto; padding: 4px 8px; display: flex; flex-direction: column; gap: 8px;">
        <div style="display: flex; justify-content: center; align-items: center; background: #fff; border-radius: 4px; box-shadow: 0 4px 16px rgba(0,0,0,0.08); padding: 10px;">
            <canvas id="realtimeChart" style="width:100%; height:54vh;"></canvas>
        </div>
        <div style="display: flex; gap: 8px; justify-content: center; align-items: stretch;">
            <div style="flex: 1; background: #fff; border-radius: 4px; box-shadow: 0 4px 16px rgba(0,0,0,0.08); padding: 10px; display: flex; justify-content: center; align-items: center;">
                <canvas id="staticChartLeft" style="width:100%; height:30vh;"></canvas>
            </div>
            <div style="flex: 1; background: #fff; border-radius: 4px; box-shadow: 0 4px 16px rgba(0,0,0,0.08); padding: 20px; display: flex; justify-content: center; align-items: center;">
                <canvas id="staticChartRight" style="width:100%; height:30vh;"></canvas>
            </div>
        </div>
    </div>
    <script>
        // Real-time chart data
        const realtimeData = {{ realtime_data|tojson }};
        // Check if realtimeData is empty and hide the chart if true
        if (!realtimeData || realtimeData.length === 0) {
            const realtimeChartContainer = document.getElementById('realtimeChart').parentElement;
            realtimeChartContainer.style.display = 'none';
        }
        // Group realtimeData by hour and average PH/ORP for each hour
        function getHour(ts) {
            // Assumes ts format 'YYYY-MM-DD HH:MM:SS'
            return ts ? ts.slice(0, 13) + ':00' : '';
        }
        const hourMap = {};
        realtimeData.forEach(d => {
            const hour = getHour(d.time);
            if (!hourMap[hour]) hourMap[hour] = { PH: [], ORP: [] };
            if (typeof d.PH === 'number') hourMap[hour].PH.push(d.PH);
            if (typeof d.ORP === 'number') hourMap[hour].ORP.push(d.ORP);
        });
        // 反转顺序，使左侧为最早日期，右侧为最近日期
        const hourLabels = Object.keys(hourMap).reverse();
        // 获取所有有数据的日期
        // X轴为最近10天所有小时点，无数据则为null
        function getRecentHours(days) {
            const result = [];
            const now = new Date();
            for (let d = days - 1; d >= 0; d--) {
                let date = new Date(now);
                date.setDate(now.getDate() - d);
                for (let h = 0; h < 24; h++) {
                    for (let m = 0; m < 60; m += 30) {
                        let dt = new Date(date);
                        dt.setHours(h, m, 0, 0);
                        if (dt > now) {
                            // 如果生成的时间大于当前时间，则不添加
                            break;
                        }
                        result.push(dt);
                    }
                }
            }
            return result;
        }
        const hourObjs = getRecentHours(10);
        const dateLabels = hourObjs.map(dt => dt.toLocaleString(navigator.language, { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }));

        // Define your local formatting options
        const local_options = {
            year: 'numeric',
            month: '2-digit',   // Ensures two digits, e.g., 07
            day: '2-digit',     // Ensures two digits, e.g., 07
            hour: '2-digit',    // Ensures two digits, e.g., 09
            minute: '2-digit',  // Ensures two digits, e.g., 05
            // No 'second' here, as your target 'YYYY-MM-DD HHM' doesn't include seconds
            hour12: false       // Use 24-hour format (00-23)
        };

        function findValueForHour(dt, key) {
            // dt: Date object, key: 'PH' or 'ORP'
            // target: 'YYYY-MM-DD HHM', where M is minute (00 or 30)

            console.log('original dt:', dt, 'key:', key);

            // 1. Get the local date and time string using toLocaleString()
            //    This will give you something like "2025/07/28, 09:05" (format depends on user's locale)
            let formattedLocalTime = dt.toLocaleString(undefined, local_options);

            // 2. Transform this string into the desired 'YYYY-MM-DD HH:MM' format.
            //    This is crucial for consistent comparison across different user locales.
            //    We'll extract parts and reassemble to ensure YYYY-MM-DD always.

            const year = dt.getFullYear();
            const month = (dt.getMonth() + 1).toString().padStart(2, '0'); // getMonth() is 0-indexed
            const day = dt.getDate().toString().padStart(2, '0');
            const hours = dt.getHours().toString().padStart(2, '0');
            const minutes = dt.getMinutes().toString().padStart(2, '0'); // Already 00 or 30 for your case

            // This creates the exact format 'YYYY-MM-DD HH:MM' using local time values
            const ymdhm = `${year}-${month}-${day} ${hours}:${minutes}`;

            // Now, loop through realtimeData to find a match
            for (let i = 0; i < realtimeData.length; i++) {
                const t = realtimeData[i].time;
                // Check if realtimeData[i].time starts with our generated local time string
                if (t && t.startsWith(ymdhm)) {
                    // Return the value if it's a number, otherwise null
                    return typeof realtimeData[i][key] === 'number' ? realtimeData[i][key] : null;
                }
            }
            return null; // Return null if no match is found
        }

        const phHourValues = hourObjs.map(dt => findValueForHour(dt, 'PH'));
        const orpHourValues = hourObjs.map(dt => findValueForHour(dt, 'ORP'));


        const realtimeElem = document.getElementById('realtimeChart');
        let lastLabel = "Jan 1";
        // 只设置宽度，保持高度由CSS控制
        realtimeElem.width = realtimeElem.parentElement.offsetWidth;
        const ctxRealtime = realtimeElem.getContext('2d');
        // 统一颜色常量
        const COLOR_GREEN = 'rgba(0, 200, 80, 1)';
        const COLOR_BLUE = 'rgba(54, 162, 235, 1)';
        const COLOR_RED = 'rgba(255, 99, 132, 1)';
        const COLOR_YELLOW = 'rgba(255, 206, 86, 1)';
        const COLOR_TEAL = 'rgba(75, 192, 192, 1)';
        const COLOR_PURPLE = 'rgba(153, 102, 255, 1)';
        const COLOR_ORANGE = 'rgba(255, 159, 64, 0.24)';
        const COLOR_PINK = 'rgba(255, 105, 180, 1)';
        const COLOR_BROWN = 'rgba(160, 82, 45, 1)';
        const COLOR_GRAY = 'rgba(128, 128, 128, 0.12)';
        const COLOR_BLACK = 'rgba(0, 0, 0, 1)';
        const COLOR_CYAN = 'rgba(0, 255, 255, 1)';
        const COLOR_LIME = 'rgba(50, 205, 50, 1)';
        const COLOR_GOLD = 'rgba(255, 215, 0, 1)';

        const skipped = (ctx, value) => ctx.p0.skip || ctx.p1.skip ? value : undefined;

        const COLORS = {
            ph: COLOR_ORANGE,
            orp: COLOR_BLUE,
            n: COLOR_TEAL,
            p: COLOR_RED,
            ca: COLOR_YELLOW,
            mg: COLOR_GRAY,
            kh: COLOR_PURPLE,
            t: COLOR_GREEN,
        };

        const realtimeChart = new Chart(ctxRealtime, {
            type: 'line',
            data: {
                labels: dateLabels,
                datasets: [
                    {
                        label: 'PH',
                        data: phHourValues,
                        borderColor: COLORS.ph,
                        backgroundColor: COLORS.ph, // Add transparency for fill color
                        fill: true, // Enable area fill
                        tension: 0.4,
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        yAxisID: 'yLeft',
                        spanGaps: true,
                        segment: {
                            borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                            borderDash: ctx => skipped(ctx, [6, 6]),
                        }
                    },
                    {
                        label: 'ORP',
                        data: orpHourValues,
                        borderColor: COLORS.orp,
                        fill: false,
                        tension: 0.4,
                        borderWidth: 3,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        yAxisID: 'yRight',
                        spanGaps: true,
                        segment: {
                            borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                            borderDash: ctx => skipped(ctx, [6, 6]),
                        }
                    }
                ]
            },
            options: {
                responsive: true,
                interaction: {
                    mode: 'index',
                    axis: 'x',
                    intersect: false
                },
                scales: {
                    x: {
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 12
                            },
                            autoSkip: false,
                            callback: function(value, index, ticks) {
                                // 调试输出 value, index, label
                                const label = this.getLabelForValue(value);
                                const labelParts = label.split(', ')[0];
                                
                                // 只显示label包含', 12 AM'的点，且只显示日期部分
                                if (label.includes('12 AM')) {
                                    if (lastLabel !== labelParts) {
                                        lastLabel = labelParts;
                                        return labelParts;
                                    } 
                                }
                                return '';
                            }
                        },
                        grid: {
                            // 使用回调函数控制 lineWidth
                            lineWidth: function(context) {
                                // context.index 是当前网格线的索引
                                // 例如，只显示偶数索引的竖线
                                if (context.index % 24 === 0) {
                                    return 1; // 显示线宽为 1px 的竖线
                                }
                                return 0; // 隐藏（线宽为 0）
                            },
                            color: 'rgba(180,180,180,0.12)', // 设置淡灰色竖线
                            drawTicks: false,
                            drawOnChartArea: true,
                            drawBorder: true
                        }
                        
                    },
                    yLeft: {
                        type: 'linear',
                        position: 'left',
                        beginAtZero: false,
                        suggestedMax: 1.2 * Math.max(...phHourValues.filter(v => v !== null)),
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 14
                            }
                        },
                        grid: {
                            color: 'rgba(180,180,180,0.12)'
                        }
                    },
                    yRight: {
                        type: 'linear',
                        position: 'right',
                        beginAtZero: false,
                        suggestedMax: 1.002 * Math.max(...orpHourValues.filter(v => v !== null)),
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 14
                            }
                        },
                        grid: {
                            drawOnChartArea: false
                        }
                    }
                },
                plugins: {
                    title: {
                        display: false, // Enable title
                        text: 'Real Time Tracking', // Title for the right chart
                        font: {
                            family: 'Oswald',
                            size: 14
                        },
                        align: 'top'
                    },
                    legend: {
                        display: true, // Enable legend
                        position: 'top', // Position legend at the top
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'index',
                        intersect: false,
                        bodyFont: {
                            family: 'Oswald',
                            size: 14
                        },
                        callbacks: {
                            title: function(context) {
                                // context[0] is the hovered item
                                const idx = context[0].dataIndex;
                                const dt = hourObjs[idx];
                                let timeLabel = '';
                                if (dt instanceof Date) {
                                    const month = dt.toLocaleString('en-US', { month: 'short' });
                                    const day = dt.getDate();
                                    let hour = dt.getHours();
                                    let minute = dt.getMinutes();
                                    let ampm = hour >= 12 ? 'PM' : 'AM';
                                    hour = hour % 12;
                                    if (hour === 0) hour = 12;
                                    timeLabel = `${month} ${day} ${hour}:${minute.toString().padStart(2, '0')}${ampm}`;
                                }
                                return timeLabel;
                            },
                            label: function(context) {
                                const key = context.dataset.label;
                                const idx = context.dataIndex;
                                let value = 'N/A';
                                if (key === 'ORP' && typeof orpHourValues[idx] !== 'undefined') {
                                    value = orpHourValues[idx];
                                } else if (key === 'PH' && typeof phHourValues[idx] !== 'undefined') {
                                    value = phHourValues[idx];
                                }
                                return `${key}: ${value}`;
                            }
                        }
                    }
                }
            }
        });
        const rawData = {{ chart_data|tojson }};
        const chartElem = document.getElementById('staticChartLeft');
        const chartRightElem = document.getElementById('staticChartRight');
        // Set canvas to fill parent div
        chartElem.width = chartElem.parentElement.offsetWidth;
        chartElem.height = chartElem.parentElement.offsetHeight;
        chartRightElem.width = chartRightElem.parentElement.offsetWidth;
        chartRightElem.height = chartRightElem.parentElement.offsetHeight;
        const ctx = chartElem.getContext('2d');
        const ctxRight = chartRightElem.getContext('2d');
        const colorPalette = [
            COLORS.n, // blue
            COLORS.p, // red
            COLORS.ca, // yellow
            COLORS.mg, // teal
            COLORS.kh, // purple
            COLORS.orange // orange
        ];

        // Helper to get week start from date string (assumes format 'Mon DD')
        function getWeekStart(dateStr) {
            const d = new Date(dateStr + ', 2025');
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // adjust when day is Sunday
            const monday = new Date(d.setDate(diff));
            return monday.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        // Group all entries by week
        const weekMap = {};
        rawData.forEach(d => {
            const week = getWeekStart(d.date);
            if (!weekMap[week]) weekMap[week] = {};
            ['N','P','CA','MG','KH'].forEach(key => {
                if (d[key] !== undefined) {
                    if (!weekMap[week][key]) weekMap[week][key] = [];
                    weekMap[week][key].push(d[key]);
                }
            });
        });

        // Aggregate values for each week (average)
        function avg(arr) {
            if (!arr || arr.length === 0) return null;
            return parseFloat((arr.reduce((a,b) => a+b,0) / arr.length).toFixed(2));
        }

        const labels = Object.keys(weekMap);
        const elementKeys = ['N', 'P'];

        const elementData = {};  
        elementKeys.forEach(key => {
            elementData[key] = labels.map(week => {
                const arr = weekMap[week][key];
                return arr ? avg(arr) : null;
            });
        });

        const elementKeysRight = ['CA', 'MG', 'KH'];
        const elementDataRight = {};
        elementKeysRight.forEach(key => {
            elementDataRight[key] = labels.map(week => {
                const arr = weekMap[week][key];
                return arr ? avg(arr) : null;
            });
        });

        // Store original data for tooltips
        const originalData = elementData;
        const originalDataRight = elementDataRight;

        // 获取最新的PH、ORP、温度和元素周均值
        function getLatestRealtime() {
            if (!realtimeData || realtimeData.length === 0) return { PH: '--', ORP: '--', T: '--', N: '--', P: '--', KH: '--', CA: '--', MG: '--' };
            // 按时间倒序
            const sorted = [...realtimeData].sort((a, b) => (b.time > a.time ? 1 : -1));
            const latest = sorted[0];

            return {
                PH: typeof latest.PH === 'number' ? latest.PH : '--',
                ORP: typeof latest.ORP === 'number' ? latest.ORP : '--',
                T: typeof latest.T === 'number' ? latest.T : '--'
            };
        }

        // Assign yAxisID: No3 on left, Po4 on right
        function getAxis(key) {
            return key === 'N' ? 'yLeft' : 'yRight';
        }
        const datasetsLeft = elementKeys.map((key, idx) => ({
            label: key === 'N' ? 'Nitrate' : key === 'P' ? 'Phosphate' : key,
            data: elementData[key],
            borderColor: colorPalette[idx % colorPalette.length],
            backgroundColor: colorPalette[idx % colorPalette.length].replace('1)', '0.2)'), // Add transparency for fill color
            fill: true, // Enable area fill
            tension: 0.4,
            borderWidth: 2, // Reduced line thickness
            pointRadius: 0,
            yAxisID: getAxis(key),
            segment: {
                borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                borderDash: ctx => skipped(ctx, [6, 6]),
            }
        }));

        // Right chart: all on left axis
        function getAxisRight(key) {
            return key === 'KH' ? 'yLeft' : 'yRight';
        }
        const datasetsRight = elementKeysRight.map((key, idx) => {
            if (key === 'MG' || key === 'CA') {
                return {
                    label: key === 'MG' ? 'Magnesium' : 'Calcium',
                    data: elementDataRight[key],
                    backgroundColor: colorPalette[(idx + 2) % colorPalette.length],
                    type: 'bar',
                    stack: 'Stack 1',
                    yAxisID: getAxisRight(key),
                    segment: {
                            borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                            borderDash: ctx => skipped(ctx, [6, 6]),
                    }
                };
            } else {
                return {
                    label: key === 'KH' ? 'Alk' : key,
                    data: elementDataRight[key],
                    borderColor: colorPalette[(idx + 2) % colorPalette.length],
                    fill: false,
                    type: 'line',
                    tension: 0.4,
                    borderWidth: 2,
                    pointRadius: 0,
                    yAxisID: getAxisRight(key),
                    segment: {
                            borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                            borderDash: ctx => skipped(ctx, [6, 6]),
                    }
                };
            }
        });

        const myChartLeft = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasetsLeft
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 13
                            }
                        },
                        grid: {
                            drawTicks: false,
                            drawOnChartArea: true,
                            drawBorder: true,
                            color: 'rgba(180,180,180,0.12)'
                        }
                    },
                    yLeft: {
                        type: 'linear',
                        position: 'left',
                        beginAtZero: true,
                        suggestedMax: 1.3 * Math.max(...elementData['N'].filter(v => v !== null)),

                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 14
                            }
                        },
                        grid: {
                            color: 'rgba(180,180,180,0.12)'
                        }
                    },
                    yRight: {
                        type: 'linear',
                        position: 'right',
                        beginAtZero: true,
                        suggestedMax: 1.1 * Math.max(...elementData['P'].filter(v => v !== null)),
                        
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 14
                            }
                        },
                        grid: {
                            drawOnChartArea: false
                        }
                    }
                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                },
                plugins: {
                    title: {
                        display: false, // Enable title
                        text: 'Nutrition', // Title for the left chart
                        font: {
                            family: 'Oswald',
                            size: 14
                        },
                        align: 'start'
                    },
                    legend: {
                        display: true, // Enable legend
                        position: 'top', // Position legend at the top
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'index',
                        intersect: false,
                        bodyFont: {
                            family: 'Oswald',
                            size: 14
                        },
                        callbacks: {
                            label: function(context) {
                                // label 映射到数据 key
                                const labelMap = {
                                    'Nitrate': 'N',
                                    'Phosphate': 'P',
                                    'Calcium': 'CA',
                                    'Magnesium': 'MG',
                                    'Alk': 'KH',
                                    'KH': 'KH',
                                    'CA': 'CA',
                                    'MG': 'MG',
                                    'N': 'N',
                                    'P': 'P'
                                };
                                let key = context.dataset.label;
                                key = labelMap[key] || key;
                                const idx = context.dataIndex;
                                let value = 'N/A';
                                if (originalData[key] && typeof originalData[key][idx] !== 'undefined') {
                                    value = originalData[key][idx];
                                }
                                return context.dataset.label + ': ' + value;
                            }
                        }
                    }
                }
            }
        });

        // Right chart
        const myChartRight = new Chart(ctxRight, {
            type: 'bar', // Set the default type to bar for stacked bars
            data: {
                labels: labels,
                datasets: datasetsRight
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        stacked: true, // Enable stacking for x-axis
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 13
                            }
                        },
                        grid: {
                            drawTicks: false,
                            drawOnChartArea: true,
                            drawBorder: true,
                            color: 'rgba(180,180,180,0.12)'
                        }
                    },
                    yLeft: {
                        type: 'linear',
                        position: 'left',
                        beginAtZero: true,
                        stacked: false, // Disable stacking for yLeft
                        suggestedMax: 1.15 * Math.max(...elementDataRight['KH'].filter(v => v !== null)),
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 14
                            }
                        },
                        grid: {
                            color: 'rgba(180,180,180,0.12)'
                        }
                    },
                    yRight: {
                        type: 'linear',
                        position: 'right',
                        beginAtZero: true,
                        stacked: false, // Enable stacking for yRight
                        suggestedMax: Math.max(
                            1 * Math.max(...elementDataRight['CA'].filter(v => v !== null)),
                            1 * Math.max(...elementDataRight['MG'].filter(v => v !== null))
                        ),
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 14
                            }
                        },
                        grid: {
                            drawOnChartArea: false
                        }
                    }
                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                },
                plugins: {
                    title: {
                        display: false, // Enable title
                        text: 'Huge Elements', // Title for the right chart
                        font: {
                            family: 'Oswald',
                            size: 14
                        },
                        align: 'top'
                    },
                    legend: {
                        display: true, // Enable legend
                        position: 'top', // Position legend at the top
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'index',
                        intersect: false,
                        bodyFont: {
                            family: 'Oswald',
                            size: 14
                        },
                        callbacks: {
                            label: function(context) {
                                // label 映射到数据 key
                                const labelMap = {
                                    'Nitrate': 'N',
                                    'Phosphate': 'P',
                                    'Calcium': 'CA',
                                    'Magnesium': 'MG',
                                    'Alk': 'KH',
                                    'KH': 'KH',
                                    'CA': 'CA',
                                    'MG': 'MG',
                                    'N': 'N',
                                    'P': 'P'
                                };
                                let key = context.dataset.label;
                                key = labelMap[key] || key;
                                const idx = context.dataIndex;
                                let value = 'N/A';
                                if (originalDataRight[key] && typeof originalDataRight[key][idx] !== 'undefined') {
                                    value = originalDataRight[key][idx];
                                }
                                return context.dataset.label + ': ' + value;
                            }
                        }
                    }
                }
            }
        });
    </script>
</body>
</html>
