<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>故事线</title>
    <!-- Include Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 媒体查询：当屏幕宽度小于640px时应用缩放 */
        @media (max-width: 640px) {
            body {
                /* 将整个页面的内容缩放到50% */
                transform: scale(0.4);
                /* 确保缩放从左上角开始，而不是中心 */
                transform-origin: top left;
                /* 调整页面的尺寸以容纳被缩放的内容，并启用滚动 */
                width: 260vw;
                height: 20vh;
                overflow-x: auto; /* 允许水平滚动 */
            }
        }

        .action-btn, .header-action-btn, .footer-action-btn, #add-node-button {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        .timeline-item:hover .action-btn,
        .action-btn:hover {
            opacity: 1;
            pointer-events: auto;
        }
        /* Header action button visibility on hover */
        .container:hover > .header-action-btn,
        .header-action-btn:hover {
            opacity: 1;
            pointer-events: auto;
        }
        /* Footer action button visibility on hover */
        footer .container:hover .footer-action-btn,
        .footer-action-btn:hover {
            opacity: 1;
            pointer-events: auto;
        }
        /* Add node button visibility on hover */
        .flex.justify-center:hover #add-node-button,
        #add-node-button:hover {
            opacity: 1;
            pointer-events: auto;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        /* Header font size smaller */
        #main-title {
            font-size: 1.6rem !important;
        }
        #subtitle {
            font-size: 1rem !important;
        }
        /* Timeline styles */
        .timeline {
            position: relative;
            overflow: visible !important;
        }
        .timeline-item {
            position: relative;
            padding: 1rem 0;
            width: 50%;
            z-index: 2; /* Ensure timeline items are above the connector lines */
        }
        .timeline-item.is-right {
            margin-left: 50%;
            padding-left: 5.5rem;
            text-align: left;
            transform: translateX(10%);
        }
        .timeline-item.is-left {
            margin-right: 50%;
            padding-right: 5.5rem;
            text-align: right;
            transform: translateX(-10%);
        }
        .timeline-dot {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border: 4px solid;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .timeline-item.is-left .timeline-dot {
            right: 20px;
            transform: translateY(-50%) translateX(30%);
        }
        .timeline-item.is-left .bg-white {
            margin-right: 40px;
        }
        .timeline-item.is-right .timeline-dot {
            left: 20px;
            transform: translateY(-50%) translateX(-30%);
        }
        .timeline-item.is-right .bg-white {
            margin-left: 40px;
        }
        .timeline-divider {
            height: 4px;
            width: 100%;
            margin: 0.5rem 0;
        }
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 50;
            background: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        .modal.active {
            display: flex;
        }
        /* SVG connector line styles */
        .timeline-connector {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw !important;
            min-width: 100vw !important;
            height: 100%;
            min-height: 100%;
            pointer-events: none;
            overflow: visible;
            z-index: 1; /* Ensure connectors are behind the timeline items */
        }
        /* Custom confirmation modal styles */
        #confirm-modal {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 50;
            background: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        #confirm-modal.active {
            display: flex;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Header Section -->
    <header class="bg-gray-800 text-white p-6 md:p-8 rounded-b-lg shadow-xl">
        <div class="container mx-auto flex flex-col md:flex-row justify-between items-center">
            <div id="header-content" class="text-center md:text-left">
                <h1 id="main-title" class="text-3xl md:text-4xl lg:text-5xl font-extrabold tracking-tight mb-2">THE LOVE STORY</h1>
                <p id="subtitle" class="text-lg md:text-xl text-gray-300">A Journey Through Time for you or what you love</p>
            </div>
            <button onclick="openHeaderModal()" class="header-action-btn mt-4 md:mt-0 px-6 py-2 bg-blue-600 text-white rounded-full hover:bg-blue-700 transition-colors shadow-md">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.389-8.379-2.83-2.828z" />
                </svg>
            </button>
        </div>
    </header>

    <!-- Main Content Section -->
    <main class="container mx-auto px-4 py-8">
        <div class="flex justify-center mb-8">
            <button id="add-node-button" onclick="openAddModal()" class="header-action-btn flex items-center justify-center w-14 h-14 bg-green-600 text-white rounded-full hover:bg-green-700 transition-colors shadow-lg text-3xl">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                </svg>
            </button>
        </div>
        <div id="timeline-container" class="timeline relative max-w-4xl mx-auto mt-12">
            <!-- SVG container for drawing the connector lines -->
            <svg id="timeline-connector-svg" class="timeline-connector"></svg>
            <!-- Timeline items will be rendered here by JavaScript -->
        </div>
    </main>

    <!-- Footer Section -->
    <footer class="bg-gray-800 text-white p-4 text-center rounded-t-lg mt-8 shadow-xl">
        <div class="container mx-auto flex items-center justify-center gap-2">
            <p id="footer-text" class="text-sm mb-0">© 2024 The Love Company. All rights reserved.</p>
            <button onclick="openFooterModal()" class="footer-action-btn px-4 py-1 text-xs bg-blue-600 text-white rounded-full hover:bg-blue-700 transition-colors shadow-md ml-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.389-8.379-2.83-2.828z" />
                </svg>
            </button>
        </div>
    </footer>

    <!-- Modals for editing -->

    <!-- Modal for adding/editing a timeline node -->
    <div id="node-modal" class="modal fixed inset-0 bg-black bg-opacity-50 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md">
            <h2 id="modal-title" class="text-2xl font-bold mb-4">增加新节点</h2>
            <form id="node-form" class="space-y-4">
                <div>
                    <label for="nodeName" class="block text-sm font-medium text-gray-700">节点名 (如: Week 1)</label>
                    <input type="text" id="nodeName" name="nodeName" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2" required>
                </div>
                <div>
                    <label for="title" class="block text-sm font-medium text-gray-700">标题 (如: Initial Consult)</label>
                    <input type="text" id="title" name="title" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2" required>
                </div>
                <div>
                    <label for="content" class="block text-sm font-medium text-gray-700">内容 (不超过50字)</label>
                    <textarea id="content" name="content" rows="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2" maxlength="50" required></textarea>
                </div>
                <div>
                    <label for="color" class="block text-sm font-medium text-gray-700">颜色</label>
                    <input type="color" id="color" name="color" value="#10b981" class="mt-1 block w-full h-10 rounded-md border-gray-300 shadow-sm p-1">
                </div>
                <div>
                    <label for="imageUpload" class="block text-sm font-medium text-gray-700">图片 (100x100 裁剪)</label>
                    <input type="file" id="imageUpload" name="imageUpload" accept="image/*" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                </div>
                <div class="flex justify-end space-x-2">
                    <button type="button" onclick="closeModal('node-modal')" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">取消</button>
                    <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">保存</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal for editing header -->
    <div id="header-modal" class="modal fixed inset-0 bg-black bg-opacity-50 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md">
            <h2 class="text-2xl font-bold mb-4">修改头部</h2>
            <form id="header-form" class="space-y-4">
                <div>
                    <label for="modal-main-title" class="block text-sm font-medium text-gray-700">主标题</label>
                    <input type="text" id="modal-main-title" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2">
                </div>
                <div>
                    <label for="modal-subtitle" class="block text-sm font-medium text-gray-700">副标题</label>
                    <input type="text" id="modal-subtitle" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2">
                </div>
                <div class="flex justify-end space-x-2">
                    <button type="button" onclick="closeModal('header-modal')" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">取消</button>
                    <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">保存</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal for editing footer -->
    <div id="footer-modal" class="modal fixed inset-0 bg-black bg-opacity-50 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md">
            <h2 class="text-2xl font-bold mb-4">修改页脚</h2>
            <form id="footer-form" class="space-y-4">
                <div>
                    <label for="modal-footer-text" class="block text-sm font-medium text-gray-700">页脚文本</label>
                    <input type="text" id="modal-footer-text" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2">
                </div>
                <div class="flex justify-end space-x-2">
                    <button type="button" onclick="closeModal('footer-modal')" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">取消</button>
                    <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">保存</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Custom Confirmation Modal -->
    <div id="confirm-modal" class="modal">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm">
            <h2 id="confirm-title" class="text-xl font-bold mb-4">确认</h2>
            <p id="confirm-message" class="mb-6 text-gray-700">你确定要执行此操作吗？</p>
            <div class="flex justify-end space-x-2">
                <button type="button" id="confirm-cancel" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">取消</button>
                <button type="button" id="confirm-ok" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">确定</button>
            </div>
        </div>
    </div>

    <script>
        // Custom modal replacement for alert() and confirm()
        function showCustomConfirm(message, title = '确认操作') {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirm-modal');
                const titleEl = document.getElementById('confirm-title');
                const messageEl = document.getElementById('confirm-message');
                const okBtn = document.getElementById('confirm-ok');
                const cancelBtn = document.getElementById('confirm-cancel');

                titleEl.textContent = title;
                messageEl.textContent = message;
                modal.classList.add('active');

                const onOk = () => {
                    modal.classList.remove('active');
                    okBtn.removeEventListener('click', onOk);
                    cancelBtn.removeEventListener('click', onCancel);
                    resolve(true);
                };
                const onCancel = () => {
                    modal.classList.remove('active');
                    okBtn.removeEventListener('click', onOk);
                    cancelBtn.removeEventListener('click', onCancel);
                    resolve(false);
                };

                okBtn.addEventListener('click', onOk);
                cancelBtn.addEventListener('click', onCancel);
            });
        }
        
        // Global variable to store node data
        let nodesData = [];
        
        // Define an array of 7 darker colors
         const macaronColors = [
            "#B3E0F2", // Powder Blue
            "#F9D3E6", // Pale Pink
            "#C4E8D0", // Mint Green
            "#F9EBAD", // Creamy Yellow
            "#DED0F2", // Lavender
            "#F0B3B3", // Coral Pink
            "#B3D9FF"  // Sky Blue
        ];

        const API_URL = 'http://192.168.0.28:5003/api/timeline';
        let editingNodeId = null;

        // Fetch and render timeline nodes
        async function fetchAndRenderNodes() {
            try {
                const response = await fetch(API_URL);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                nodesData = await response.json(); // Store data in a global variable
                renderTimeline(nodesData);
                // Call renderConnectors after a short delay to allow for DOM rendering
                setTimeout(() => {
                    renderConnectors(nodesData);
                }, 100);
            } catch (error) {
                console.error("Failed to fetch timeline nodes:", error);
                renderTimeline([]); // Do not display any nodes
                renderConnectors([]); // Do not display any connector lines
            }
        }
        
        // Render the timeline UI
        function renderTimeline(nodes) {
            const container = document.getElementById('timeline-container');
            // Find the SVG element and clear the container content without removing the SVG
            const svgElement = document.getElementById('timeline-connector-svg');
            container.innerHTML = '';
            container.appendChild(svgElement);


            nodes.forEach((node, index) => {
                const isRight = index % 2 === 1;
                const alignmentClass = 'timeline-item ' + (isRight ? 'is-right' : 'is-left');
                // 按钮始终在远离中心的一侧
                const actionBtnDiv = isRight
                  ? `<div class="absolute top-2 right-2 flex space-x-2">
                        <button onclick="openEditModal('${node.id}')" class="action-btn rounded-full bg-blue-500 hover:bg-blue-600 text-white shadow-md p-2 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-300" title="编辑">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.389-8.379-2.83-2.828z" />
                            </svg>
                        </button>
                        <button onclick="deleteNode('${node.id}')" class="action-btn rounded-full bg-red-500 hover:bg-red-600 text-white shadow-md p-2 transition-colors focus:outline-none focus:ring-2 focus:ring-red-300" title="删除">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>`
                  : `<div class="absolute top-2 left-2 flex space-x-2">
                        <button onclick="openEditModal('${node.id}')" class="action-btn rounded-full bg-blue-500 hover:bg-blue-600 text-white shadow-md p-2 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-300" title="编辑">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.389-8.379-2.83-2.828z" />
                            </svg>
                        </button>
                        <button onclick="deleteNode('${node.id}')" class="action-btn rounded-full bg-red-500 hover:bg-red-600 text-white shadow-md p-2 transition-colors focus:outline-none focus:ring-2 focus:ring-red-300" title="删除">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>`;

                const html = `
                    <div class="${alignmentClass} flex items-center mb-10" id="node-${node.id}">
                        <div class="relative w-full">
                            <div class="bg-white rounded-lg p-6 shadow-lg">
                                <div class="mb-2">
                                    <h3 class="font-extrabold text-2xl text-gray-900 leading-tight">${node.nodeName}</h3>
                                    <h4 class="font-semibold text-lg text-gray-800 mt-1" style="margin-left:0;">${node.title}</h4>
                                </div>
                                <div class="timeline-divider" style="background-color: ${node.color};"></div>
                                <p class="mt-2 text-gray-600 text-left">${node.content}</p>
                                ${actionBtnDiv}
                            </div>
                        </div>
                        <div class="timeline-dot" style="border-color: ${node.color};" id="dot-${node.id}">
                            <img src="${node.image}" alt="Node Icon" style="width:108px;height:108px;object-fit:cover;border-radius:9999px;">
                        </div>
                    </div>
                `;
                container.innerHTML += html;
            });
        }
        
        // Renders the timeline connector lines
        function renderConnectors(nodes) {
            const svg = document.getElementById('timeline-connector-svg');
            if (!svg) return;
            // Clear existing lines
            svg.innerHTML = '';
            if (nodes.length <= 1) return;
            // Always get up-to-date bounding rect (after scaling)
            const rect = svg.parentElement.getBoundingClientRect();
            // 保持 desktop 和 mobile 坐标系一致，全部用缩放后的坐标
            svg.setAttribute('width', rect.width);
            svg.setAttribute('height', rect.height);
            let dotRadius = 60;
            const gap = 15;
            for (let i = 0; i < nodes.length - 1; i++) {
                const currentNodeId = nodes[i].id;
                const nextNodeId = nodes[i+1].id;
                const currentDot = document.getElementById(`dot-${currentNodeId}`);
                const nextDot = document.getElementById(`dot-${nextNodeId}`);
                if (currentDot && nextDot) {
                    let currentRect = currentDot.getBoundingClientRect();
                    let nextRect = nextDot.getBoundingClientRect();
                    let rectLeft = rect.left;
                    let rectTop = rect.top;
                    let scale = 1;
                    if (window.innerWidth < 640) {
                        scale = 0.4;
                        rectLeft = rect.left / scale;
                        rectTop = rect.top / scale;
                        currentRect = {
                            left: (currentRect.left + window.scrollX) / scale,
                            top: (currentRect.top + window.scrollY) / scale,
                            width: currentRect.width / scale,
                            height: currentRect.height / scale
                        };
                        nextRect = {
                            left: (nextRect.left + window.scrollX) / scale,
                            top: (nextRect.top + window.scrollY) / scale,
                            width: nextRect.width / scale,
                            height: nextRect.height / scale
                        };
                    }
                    const currentCenterX = currentRect.left + currentRect.width / 2 - rectLeft;
                    const currentCenterY = currentRect.top + currentRect.height / 2 - rectTop;
                    const nextCenterX = nextRect.left + nextRect.width / 2 - rectLeft;
                    const nextCenterY = nextRect.top + nextRect.height / 2 - rectTop;
                    // Calculate the distance and angle between the two centers
                    const dx = nextCenterX - currentCenterX;
                    const dy = nextCenterY - currentCenterY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const lineColor = nodes[i+1].color;
                    console.log(`Drawing line from ${currentNodeId} to ${nextNodeId} with color ${lineColor}`);
                    console.log(`Current distance: (${distance}), dotRadius:(${dotRadius}),  gap: (${gap})`);

                    if (distance > 0) {
                        const unitX = dx / distance;
                        const unitY = dy / distance;
                        const startX = currentCenterX + unitX * (dotRadius + gap);
                        const startY = currentCenterY + unitY * (dotRadius + gap);
                        const endX = nextCenterX - unitX * (dotRadius + gap);
                        const endY = nextCenterY - unitY * (dotRadius + gap);
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', startX);
                        line.setAttribute('y1', startY);
                        line.setAttribute('x2', endX);
                        line.setAttribute('y2', endY);
                        line.setAttribute('stroke', lineColor);
                        line.setAttribute('stroke-width', '4');
                        line.setAttribute('stroke-linecap', 'round');
                        svg.appendChild(line);
                    }
                }
            }
        }

        // --- Mobile/resize fix: use ResizeObserver and orientationchange to redraw connectors ---
        function setupConnectorObservers() {
            const container = document.getElementById('timeline-container');
            if (!container) return;
            // Use ResizeObserver for container size changes (including mobile scaling)
            if (window.ResizeObserver) {
                const ro = new ResizeObserver(() => {
                    renderConnectors(nodesData);
                });
                ro.observe(container);
            }
            // Redraw on orientation change
            window.addEventListener('orientationchange', () => {
                setTimeout(() => renderConnectors(nodesData), 300);
            });
        }

        // --- CRUD Operations ---

        // Add a new node
        async function addNode(nodeData) {
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(nodeData)
                });
                if (!response.ok) {
                    throw new Error('Failed to add node');
                }
                await fetchAndRenderNodes();
            } catch (error) {
                console.error("Error adding node:", error);
            }
        }

        // Update a node
        async function updateNode(nodeId, nodeData) {
            try {
                const response = await fetch(`${API_URL}/${nodeId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(nodeData)
                });
                if (!response.ok) {
                    throw new Error('Failed to update node');
                }
                await fetchAndRenderNodes();
            } catch (error) {
                console.error("Error updating node:", error);
            }
        }

        // Delete a node
        async function deleteNode(nodeId) {
            const confirmed = await showCustomConfirm('你确定要删除这个节点吗？');
            if (!confirmed) {
                return;
            }
            try {
                const response = await fetch(`${API_URL}/${nodeId}`, {
                    method: 'DELETE'
                });
                if (!response.ok) {
                    throw new Error('Failed to delete node');
                }
                await fetchAndRenderNodes();
            } catch (error) {
                console.error("Error deleting node:", error);
            }
        }

        // Get node data for editing
        async function getNodeData(nodeId) {
            try {
                const response = await fetch(`${API_URL}/${nodeId}`);
                if (!response.ok) {
                    throw new Error('Node data not found');
                }
                return await response.json();
            } catch (error) {
                console.error(error);
                return null;
            }
        }

        // --- Modal Handling ---

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
            editingNodeId = null;
        }

        function openAddModal() {
            const modal = document.getElementById('node-modal');
            document.getElementById('modal-title').textContent = '增加新节点';
            document.getElementById('node-form').reset();
            
            // Randomly select a darker color
            const randomColor = macaronColors[Math.floor(Math.random() * macaronColors.length)];
            document.getElementById('color').value = randomColor;

            editingNodeId = null;
            modal.classList.add('active');
        }

        async function openEditModal(nodeId) {
            const modal = document.getElementById('node-modal');
            const node = await getNodeData(nodeId);
            if (!node) {
                await showCustomConfirm('该节点为示例数据，无法编辑。请先添加自己的节点。');
                return;
            }

            document.getElementById('modal-title').textContent = '修改节点';
            document.getElementById('nodeName').value = node.nodeName;
            document.getElementById('title').value = node.title;
            document.getElementById('content').value = node.content;
            document.getElementById('color').value = node.color;
            editingNodeId = nodeId;

            modal.classList.add('active');
        }

        async function fetchHeaderFooterData() {
            try {
                const response = await fetch('/api/header_footer');
                if (!response.ok) return { header: {}, footer: {} };
                return await response.json();
            } catch (e) {
                return { header: {}, footer: {} };
            }
        }

        async function fetchAndRenderHeaderFooter() {
            const data = await fetchHeaderFooterData();
            if (data.header) {
                document.getElementById('main-title').textContent = data.header.main_title || '';
                document.getElementById('subtitle').textContent = data.header.subtitle || '';
            }
            if (data.footer) {
                document.getElementById('footer-text').textContent = data.footer.footer_text || '';
            }
        }

        function openHeaderModal() {
            const modal = document.getElementById('header-modal');
            document.getElementById('modal-main-title').value = document.getElementById('main-title').textContent;
            document.getElementById('modal-subtitle').value = document.getElementById('subtitle').textContent;
            modal.classList.add('active');
        }

        function openFooterModal() {
            const modal = document.getElementById('footer-modal');
            document.getElementById('modal-footer-text').value = document.getElementById('footer-text').textContent;
            modal.classList.add('active');
        }
        
        // --- Image Cropping and Handling ---

        function cropImageAndGetBase64(file, callback) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const size = 200; // Increase resolution
                    let sourceX = 0;
                    let sourceY = 0;
                    let sourceWidth = img.width;
                    let sourceHeight = img.height;

                    if (img.width > img.height) {
                        sourceWidth = img.height;
                        sourceX = (img.width - img.height) / 2;
                    } else {
                        sourceHeight = img.width;
                        sourceY = (img.height - img.width) / 2;
                    }

                    canvas.width = size;
                    canvas.height = size;

                    ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, size, size);
                    callback(canvas.toDataURL('image/png'));
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // --- Event Listeners ---

        // Handle form submission for adding/editing nodes
        document.getElementById('node-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            const nodeData = {
                nodeName: formData.get('nodeName'),
                title: formData.get('title'),
                content: formData.get('content'),
                color: formData.get('color'),
                image: "https://placehold.co/100x100" // Default image placeholder
            };

            const imageFile = formData.get('imageUpload');
            if (imageFile && imageFile.size > 0) {
                cropImageAndGetBase64(imageFile, async (base64Image) => {
                    nodeData.image = base64Image;
                    if (editingNodeId) {
                        await updateNode(editingNodeId, nodeData);
                    } else {
                        await addNode(nodeData);
                    }
                    closeModal('node-modal');
                });
            } else {
                if (editingNodeId) {
                    // If no new image, try to keep the existing one
                    const existingNode = await getNodeData(editingNodeId);
                    if (existingNode) {
                         nodeData.image = existingNode.image;
                    }
                    await updateNode(editingNodeId, nodeData);
                } else {
                    await addNode(nodeData);
                }
                closeModal('node-modal');
            }
        });

        // Handle form submission for editing header
        document.getElementById('header-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const data = await fetchHeaderFooterData();
            const mainTitle = document.getElementById('modal-main-title').value;
            const subtitle = document.getElementById('modal-subtitle').value;
            const payload = {
                header: { main_title: mainTitle, subtitle: subtitle },
                footer: data.footer
            };
            try {
                await fetch('/api/header_footer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                await fetchAndRenderHeaderFooter();
            } catch (err) { /* ignore */ }
            closeModal('header-modal');
        });

        // Handle form submission for editing footer
        document.getElementById('footer-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const data = await fetchHeaderFooterData();
            const footerText = document.getElementById('modal-footer-text').value;
            const payload = {
                header: data.header,
                footer: { footer_text: footerText }
            };
            try {
                await fetch('/api/header_footer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                await fetchAndRenderHeaderFooter();
            } catch (err) { /* ignore */ }
            closeModal('footer-modal');
        });
        

        // Re-render connectors on window resize
        window.addEventListener('resize', () => {
            setTimeout(() => renderConnectors(nodesData), 100);
        });

        // Initial fetches on page load
        document.addEventListener('DOMContentLoaded', () => {
            fetchAndRenderHeaderFooter();
            fetchAndRenderNodes();
            setupConnectorObservers();
            // Extra redraw after 500ms for mobile scaling quirks
            setTimeout(() => renderConnectors(nodesData), 500);
        });
    </script>

</body>
</html>
