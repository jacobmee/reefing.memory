<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Reefing Memory</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css?family=Oswald:300,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Lato:300,700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Base styles for all screen sizes (Mobile-First Approach) */
        body {
            background: #f3f1f1;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        /* Main container for all charts */
        .charts-container {
            width: 100%;
            min-height: 80vh;
            margin: 4px auto;
            padding: 4px 8px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* Individual chart card styles */
        .chart-card {
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            width: 100%;
            box-sizing: border-box;
        }

        /* Heights for canvases on mobile (default) */
        #realtimeChart {
            width: 100%;
            height: 30vh;
        }
        #staticChartLeft,
        #staticChartRight {
            width: 100%;
            height: 23vh;
        }

        /* Wrapper for the two bottom charts (default stacked on mobile) */
        .bottom-charts-wrapper {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-grow: 1;
            width: 100%;
        }

        /* New styles for the elements list section */
        .elements-list {
            background: #fff;
            padding: 20px;
            padding-top: 15px;
            border-radius: 4px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
            font-family: 'Oswald', sans-serif;
            font-size: 14px;
            flex-shrink: 0;
            width: 100%;
            box-sizing: border-box;
            /* --- START MOBILE HEIGHT ADJUSTMENT --- */
            min-height: 30vh; /* 设定一个最小高度，使其在手机上更高一些 */
            overflow-y: auto; /* 如果内容溢出，允许垂直滚动 */
            /* --- END MOBILE HEIGHT ADJUSTMENT --- */
        }
        .elements-list h4 {
            margin: 0 0 15px 0;
            font-family: 'Lato', sans-serif;
            font-size: 26px;
            text-align: center;
            color: #333;
        }

        /* --- START OF CHANGES FOR MOBILE ELEMENTS LIST LAYOUT --- */
        .elements-list ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 8px 32px;
        }

        .elements-list li {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: calc(50% - 16px);
            margin-bottom: 0;
            box-sizing: border-box;
        }
        /* --- END OF CHANGES FOR MOBILE ELEMENTS LIST LAYOUT --- */

        .elements-list li:last-child {
            margin-bottom: 0;
        }

        .element-label-row {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 4px;
        }

        .element-label {
            font-weight: normal;
            color: #555;
        }

        .element-percentage {
            font-weight: bold;
            color: #333;
            min-width: 40px;
            text-align: right;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .progress-bar-threshold {
            position: absolute;
            left: 70%;
            top: 0;
            width: 2px;
            height: 100%;
            background: #888;
            opacity: 0.7;
            z-index: 2;
        }

        .progress-bar-fill {
            height: 100%;
            width: 0%;
            border-radius: 4px;
            transition: width 0.5s ease-in-out;
        }

        .top-section {
            display: flex;
            flex-direction: column; /* Mobile: stack vertically */
            align-items: flex-start;
            gap: 8px;
            width: 100%;
        }

        /* Order for mobile layout: elements-list first, then realtimeChart */
        .top-section .elements-list {
            order: 1;
        }

        .top-section .chart-card {
            order: 2;
        }


        /* --- Desktop Layout (min-width: 768px) --- */
        @media (min-width: 768px) {
            body {
                align-items: center;
            }

            .charts-container {
                flex-direction: column;
                min-height: 80vh;
            }

            #realtimeChart {
                width: 100%;
                height: 100%;
            }
            #staticChartLeft,
            #staticChartRight {
                height: 36vh;
            }

            .bottom-charts-wrapper {
                flex-direction: row;
                flex-grow: 1;
                align-items: stretch;
            }

            .bottom-charts-wrapper > .chart-card {
                flex: 1;
            }

            .top-section {
                flex-direction: row;
                align-items: stretch;
                height: 58vh;
            }

            /* Reset order for desktop */
            .top-section .elements-list {
                order: 0;
            }

            .top-section .chart-card {
                order: 0;
                flex-grow: 1;
            }

            .elements-list {
                width: 280px;
                flex-shrink: 0;
                flex-basis: 280px;
                /* 桌面视图下，min-height会被flexbox的拉伸行为覆盖 */
            }

            /* --- Desktop Specific Overrides for elements-list ul/li --- */
            .elements-list ul {
                display: block;
                gap: 0;
            }
            .elements-list li {
                width: 100%;
                margin-bottom: 12px;
            }
            .elements-list li:last-child {
                margin-bottom: 0;
            }
            /* --- END Desktop Specific Overrides --- */

            .chart-card {
                width: auto;
                flex-grow: 1;
            }
        }
    </style>
</head>
<body>
    <div class="charts-container">
        <div class="top-section">
            <div class="elements-list">
                <h4>Reefing Memory</h4>
                <ul>
                    <li id="orpElement">
                        <div class="element-label-row">
                            <span class="element-label">ORP: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="orp"></div>
                        </div>
                    </li>
                    <li id="phElement">
                        <div class="element-label-row">
                            <span class="element-label">PH: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="ph"></div>
                        </div>
                    </li>
                    <li id="tempElement">
                        <div class="element-label-row">
                            <span class="element-label">Temperature: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="t"></div>
                        </div>
                    </li>
                    <li id="nElement">
                        <div class="element-label-row">
                            <span class="element-label">Nitrate: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="n"></div>
                        </div>
                    </li>
                    <li id="pElement">
                        <div class="element-label-row">
                            <span class="element-label">Phosphate: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="p"></div>
                        </div>
                    </li>
                    <li id="caElement">
                        <div class="element-label-row">
                            <span class="element-label">Calcium: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="ca"></div>
                        </div>
                    </li>
                    <li id="mgElement">
                        <div class="element-label-row">
                            <span class="element-label">Magnesium: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="mg"></div>
                        </div>
                    </li>
                    <li id="khElement">
                        <div class="element-label-row">
                            <span class="element-label">Alkalinity: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="kh"></div>
                        </div>
                    </li>
                </ul>
            </div>

            <div class="chart-card">
                <canvas id="realtimeChart"></canvas>
            </div>
        </div>

        <div class="bottom-charts-wrapper">
            <div class="chart-card">
                <canvas id="staticChartLeft"></canvas>
            </div>
            <div class="chart-card">
                <canvas id="staticChartRight"></canvas>
            </div>
        </div>
    </div>
    <script>
        // Placeholder for your Jinja2 variables.
        // In a real Flask/Jinja2 app, these would be populated server-side.
        const realtimeData = {{ realtime_data|tojson }} || [];
        const chart_data = {{ chart_data|tojson }} || [];

        // Check if realtimeData is empty and hide the chart if true
        if (!realtimeData || realtimeData.length === 0) {
            const realtimeChartContainer = document.getElementById('realtimeChart').parentElement;
            realtimeChartContainer.style.display = 'none';
        }

        // Group realtimeData by hour and average PH/ORP for each hour
        function getHour(ts) {
            // Assumes ts format 'YYYY-MM-DD HH:MM:SS' or 'YYYY-MM-DD HH:MM:SS.000Z' (ISO String)
            // We want 'YYYY-MM-DD HH:00'
            if (!ts) return '';
            let dateObj;
            if (ts.endsWith('Z')) { // It's an ISO string (UTC), convert to local date for consistent hour extraction
                dateObj = new Date(ts);
            } else { // Assume it's a local time string or needs parsing
                // For 'YYYY-MM-DD HH:MM:SS' or 'YYYY-MM-DD HH:MM', parse it directly.
                // NOTE: Parsing date strings without Z or timezone can be problematic cross-browser.
                // If 'time' from realtimeData is always a local time, this is okay.
                // If it's mixed, consider parsing it as UTC first: new Date(ts + 'Z') or specific parsing library.
                dateObj = new Date(ts.replace(' ', 'T')); // Convert to ISO-like format for safer parsing
            }

            const year = dateObj.getFullYear();
            const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
            const day = dateObj.getDate().toString().padStart(2, '0');
            const hour = dateObj.getHours().toString().padStart(2, '0');

            return `${year}-${month}-${day} ${hour}:00`;
        }

        const hourMap = {};
        realtimeData.forEach(d => {
            const hour = getHour(d.time); // Use the corrected getHour
            if (!hourMap[hour]) hourMap[hour] = { PH: [], ORP: [] };
            if (typeof d.PH === 'number') hourMap[hour].PH.push(d.PH);
            if (typeof d.ORP === 'number') hourMap[hour].ORP.push(d.ORP);
        });

        // 获取最近10天所有30分钟点
        function getRecentHalfHours(days) {
            const result = [];
            const now = new Date(); // Current local time
            // Loop from oldest day (days-1) to current day (0)
            for (let d = days - 1; d >= 0; d--) {
                let date = new Date(now);
                date.setDate(now.getDate() - d); // Set to the target day
                
                // Every 4 hours
                for (let h = 0; h < 24; h = h + 4) {
                    
                    let dt = new Date(date); // Create new Date object for each time point
                    dt.setHours(h, 0, 0, 0); // Set hour, minute, second, millisecond

                    // Only add if the generated time is not in the future
                    if (dt <= now) {
                        result.push(dt);
                    } else {
                        // If we've passed the current time, no need to generate further points for this day
                        break; 
                    }
                    
                }
            }
            return result;
        }

        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const hourObjs = isMobile ? getRecentHalfHours(5) : getRecentHalfHours(7); // Adjusted for mobile devices
        
        // Formats labels for X-axis as 'Jul 28, 09' (24-hour)
        function formatDateLabel(dt) {
            const month = dt.toLocaleString(navigator.language, { month: 'short' });
            const day = dt.getDate().toString().padStart(2, '0');
            const hour = dt.getHours().toString().padStart(2, '0');
            return `${month} ${day}, ${hour}`;
        }
        const dateLabels = hourObjs.map(formatDateLabel);

        // findValueForHour function (already corrected in previous turn)
        function findValueForHour(dt, key) {
            // dt: Date object, key: 'PH' or 'ORP'
            // target: 'YYYY-MM-DD HH:MM'

            // Extract parts of the Date object in local timezone
            const year = dt.getFullYear();
            const month = (dt.getMonth() + 1).toString().padStart(2, '0'); // getMonth() is 0-indexed
            const day = dt.getDate().toString().padStart(2, '0');
            const hours = dt.getHours().toString().padStart(2, '0');
            const minutes = dt.getMinutes().toString().padStart(2, '0'); 

            // This creates the exact format 'YYYY-MM-DD HH:MM' using local time values
            const ymdhm = `${year}-${month}-${day} ${hours}:${minutes}`;

            for (let i = 0; i < realtimeData.length; i++) {
                const t = realtimeData[i].time;
                // Check if realtimeData[i].time starts with our generated local time string
                // Assuming realtimeData[i].time is also in local time or can be compared this way
                if (t && t.startsWith(ymdhm)) {
                    return typeof realtimeData[i][key] === 'number' ? realtimeData[i][key] : null;
                }
            }
            return null; // Return null if no match is found
        }
        
        const phHourValues = hourObjs.map(dt => findValueForHour(dt, 'PH'));
        const orpHourValues = hourObjs.map(dt => findValueForHour(dt, 'ORP'));

        const realtimeElem = document.getElementById('realtimeChart');
        let lastLabel = ""; // Renamed from lastLabel to be more specific (lastDayLabel) for X-axis callback

        // Unified color constants
        const COLORS = {
            ph: 'rgba(255, 159, 64, 0.24)',  // Orange
            orp: 'rgba(54, 162, 235, 1)', // Blue
            n: 'rgba(75, 192, 192, 1)',   // Teal
            p: 'rgba(255, 99, 132, 1)',   // Red
            ca: 'rgba(255, 206, 86, 1)',  // Yellow
            mg: 'rgba(128, 128, 128, 0.12)', // Gray (changed from transparent for better visibility)
            kh: 'rgba(153, 102, 255, 1)', // Purple
            t: 'rgba(0, 200, 80, 1)',     // Green (used for temp, but not in current charts)
        }; 

        const skipped = (ctx, value) => ctx.p0.skip || ctx.p1.skip ? value : undefined;

        const realtimeChart = new Chart(realtimeElem.getContext('2d'), {
            type: 'line',
            data: {
                labels: dateLabels,
                datasets: [
                    {
                        label: 'PH',
                        data: phHourValues,
                        borderColor: COLORS.ph,
                        backgroundColor: COLORS.ph.replace('1)', '0.2)'), // Add transparency for fill color
                        fill: true, // Enable area fill
                        tension: 0.4,
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        yAxisID: 'yLeft',
                        spanGaps: true, // Connect null points
                        segment: {
                            borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                            borderDash: ctx => skipped(ctx, [6, 6]),
                        }
                    },
                    {
                        label: 'ORP',
                        data: orpHourValues,
                        borderColor: COLORS.orp,
                        backgroundColor: COLORS.orp.replace('1)', '0.2)'),
                        fill: false, // Do not fill area for ORP
                        tension: 0.4,
                        borderWidth: 3,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        yAxisID: 'yRight',
                        spanGaps: true, // Connect null points
                        segment: {
                            borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                            borderDash: ctx => skipped(ctx, [6, 6]),
                        }
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false, // Allow CSS to control height
                interaction: {
                    mode: 'index',
                    axis: 'x',
                    intersect: false
                },
                scales: {
                    x: {
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 12
                            },
                            autoSkip: false, // We control skipping manually
                            callback: function(value, index, ticks) {
                                // Get the full label string (e.g., "Jul 27, 04:00 AM")
                                const fullLabel = this.getLabelForValue(value);

                                const datePart = fullLabel.split(',')[0];
                                // console.log("datePart: " + datePart);
                                // Only display label if it's 12 AM (midnight) for a new day
                                if (fullLabel.includes('00')) {
                                    return datePart;
                                } 
                                return ''; // Hide other labels
                            }
                        },
                        grid: {
                            drawTicks: false,
                            drawOnChartArea: true,
                            drawBorder: true,
                            color: 'rgba(180,180,180,0.12)'
                        }
                    },
                    yLeft: {
                        type: 'linear',
                        position: 'left',
                        beginAtZero: false,
                        // Calculate suggestedMax based on actual filtered values
                        suggestedMax: phHourValues.filter(v => v !== null).length > 0 ? 
                                      1.1 * Math.max(...phHourValues.filter(v => v !== null)) : 10,
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 14
                            }
                        },
                        grid: {
                            color: 'rgba(180,180,180,0.12)'
                        }
                    },
                    yRight: {
                        type: 'linear',
                        position: 'right',
                        beginAtZero: false,
                        // Calculate suggestedMax based on actual filtered values
                        suggestedMax: orpHourValues.filter(v => v !== null).length > 0 ?
                                      1.002 * Math.max(...orpHourValues.filter(v => v !== null)) : 500,
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 14
                            },
                            callback: function(value) {
                                return value.toFixed(0); // Show ORP as whole numbers
                            }
                        },
                        grid: {
                            drawOnChartArea: false // Hide horizontal grid lines for right Y-axis
                        }
                    }
                },
                plugins: {
                    title: {
                        display: false,
                        text: 'Real Time Tracking',
                        font: { family: 'Oswald', size: 14 },
                        align: 'top'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'index',
                        intersect: false,
                        bodyFont: { family: 'Oswald', size: 14 },
                        callbacks: {
                            title: function(context) {
                                // context[0] is the hovered item
                                const idx = context[0].dataIndex;
                                const dt = hourObjs[idx]; // Get the original Date object
                                
                                if (dt instanceof Date) {
                                    // Use toLocaleString for a user-friendly timestamp in their locale
                                    return dt.toLocaleString(navigator.language, { 
                                        month: 'short', 
                                        day: 'numeric', 
                                        hour: '2-digit', 
                                        minute: '2-digit', 
                                        hour12: true 
                                    });
                                }
                                return '';
                            },
                            label: function(context) {
                                const key = context.dataset.label;
                                const value = context.parsed.y;
                                let formattedValue = 'N/A';

                                if (value !== null) {
                                    switch (key) {
                                        case 'ORP':
                                            formattedValue = value.toFixed(0);
                                            break;
                                        case 'PH':
                                            formattedValue = value.toFixed(1);
                                            break;
                                        default:
                                            formattedValue = value.toFixed(0);
                                    }
                                }

                                return `${key}: ${formattedValue}`;
                            }
                        }
                    }
                }
            }
        });

        const rawData = {{ chart_data|tojson }} || [];
        const chartElem = document.getElementById('staticChartLeft');
        const chartRightElem = document.getElementById('staticChartRight');
        
        const ctx = chartElem.getContext('2d');
        const ctxRight = chartRightElem.getContext('2d');

        const colorPalette = [
            COLORS.n, // Nitrate (Teal)
            COLORS.p, // Phosphate (Red)
            COLORS.ca, // Calcium (Yellow)
            COLORS.mg, // Magnesium (Gray)
            COLORS.kh, // Alkalinity (Purple)
        ];

        // Helper to get week start from date string (assumes format like "Mon DD" or 'YYYY-MM-DD')
        // We'll try to parse it more robustly
        function getWeekStart(dateStr) {
            // First, try to parse as ISO-like, then get the date
            let d;
            if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) { // YYYY-MM-DD format
                d = new Date(dateStr + 'T00:00:00'); // Ensure it's treated as a local date
            } else { // Assume it's "Mon DD"
                d = new Date(dateStr + ', ' + new Date().getFullYear()); // Add current year for parsing
            }

            // Find Monday (week start)
            const dayOfWeek = d.getDay(); // 0 for Sunday, 1 for Monday, ..., 6 for Saturday
            const diffToMonday = d.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
            const monday = new Date(d);
            monday.setDate(diffToMonday);

            // Find Sunday (week end) for label: Monday + 6 days
            const sunday = new Date(monday);
            sunday.setDate(monday.getDate() + 6);

            // Format to "Mon DD" for labels (will show Sunday date)
            return sunday.toLocaleDateString(navigator.language, { month: 'short', day: 'numeric' });
        }

        // Group all entries by week
        const weekMap = {};
        rawData.forEach(d => {
            const week = getWeekStart(d.date);
            if (!weekMap[week]) weekMap[week] = {};
            ['N','P','CA','MG','KH'].forEach(key => {
                if (typeof d[key] === 'number') { // Only push if it's a number
                    if (!weekMap[week][key]) weekMap[week][key] = [];
                    weekMap[week][key].push(d[key]);
                }
            });
        });

        // Aggregate values for each week (average)
        function avg(arr) {
            if (!arr || arr.length === 0) return null;
            return parseFloat((arr.reduce((a,b) => a+b,0) / arr.length).toFixed(2));
        }

        const labels = Object.keys(weekMap).sort((a,b) => {
            // Custom sort for "Mon DD" format
            const dateA = new Date(a + ', ' + new Date().getFullYear());
            const dateB = new Date(b + ', ' + new Date().getFullYear());
            return dateA - dateB;
        });

        const elementKeysLeft = ['N', 'P']; // Left Chart Elements
        const elementDataLeft = {};  
        elementKeysLeft.forEach(key => {
            elementDataLeft[key] = labels.map(week => {
                const arr = weekMap[week][key];
                return arr ? avg(arr) : null;
            });
        });

        const elementKeysRight = ['CA', 'MG', 'KH']; // Right Chart Elements
        const elementDataRight = {};
        elementKeysRight.forEach(key => {
            elementDataRight[key] = labels.map(week => {
                const arr = weekMap[week][key];
                return arr ? avg(arr) : null;
            });
        });

        // Assign yAxisID: No3 on left, Po4 on right for the left chart
        function getAxisLeftChart(key) {
            return key === 'N' ? 'yLeft' : 'yRight';
        }
        const datasetsLeft = elementKeysLeft.map((key, idx) => ({
            label: key === 'N' ? 'Nitrate' : 'Phosphate', // Assuming only N and P here
            data: elementDataLeft[key],
            borderColor: COLORS[key.toLowerCase()], // Use predefined colors
            backgroundColor: COLORS[key.toLowerCase()].replace('1)', '0.2)'),
            fill: true,
            tension: 0.4,
            borderWidth: 2,
            pointRadius: 0,
            pointHoverRadius: 6,
            yAxisID: getAxisLeftChart(key),
            spanGaps: true,
            segment: {
                borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                borderDash: ctx => skipped(ctx, [6, 6]),
            }
        }));

        // Right chart: CA and MG as stacked bars, KH as line
        function getAxisRightChart(key) {
            // CA and MG might share one axis (right), KH on another (left)
            return key === 'KH' ? 'yLeft' : 'yRight';
        }
        const datasetsRight = elementKeysRight.map((key, idx) => {
            const baseColor = colorPalette[(idx + 2) % colorPalette.length]; // Re-use color palette or define more
            if (key === 'MG' || key === 'CA') {
                return {
                    label: key === 'MG' ? 'Magnesium' : 'Calcium',
                    data: elementDataRight[key],
                    backgroundColor: COLORS[key.toLowerCase()],
                    type: 'bar',
                    stack: 'elementsStack', // All bars that should stack use the same stack ID
                    yAxisID: getAxisRightChart(key),
                    order: 1,
                    segment: {
                        borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                        borderDash: ctx => skipped(ctx, [6, 6]),
                    }
                };
            } else { // KH
                return {
                    label: 'Alk', // Label for KH
                    data: elementDataRight[key],
                    borderColor: COLORS.kh,
                    backgroundColor: COLORS.kh.replace('1)', '0.2)'),
                    fill: false,
                    type: 'line',
                    tension: 0.4,
                    borderWidth: 2,
                    pointRadius: 0,
                    pointHoverRadius: 6,
                    yAxisID: getAxisRightChart(key),
                    spanGaps: true,
                    order: 0,
                    segment: {
                        borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                        borderDash: ctx => skipped(ctx, [6, 6]),
                    }
                };
            }
        });

        const myChartLeft = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasetsLeft
            },
            options: {
                responsive: true,
                maintainAspectRatio: false, // Allow CSS to control height
                scales: {
                    x: {
                        ticks: {
                            font: { family: 'Oswald', size: 13 },
                            // Improve X-axis label display for weeks
                            callback: function(value, index, ticks) {
                                // Only display every X labels if too many, or always if few
                                return this.getLabelForValue(value);
                            }
                        },
                        grid: {
                            drawTicks: false,
                            drawOnChartArea: true,
                            drawBorder: true,
                            color: 'rgba(180,180,180,0.12)'
                        }
                    },
                    yLeft: {
                        type: 'linear',
                        position: 'left',
                        beginAtZero: true,
                        suggestedMax: elementDataLeft['N'].filter(v => v !== null).length > 0 ? 
                                      1.3 * Math.max(...elementDataLeft['N'].filter(v => v !== null)) : 10,
                        ticks: { font: { family: 'Oswald', size: 14 } },
                        grid: { color: 'rgba(180,180,180,0.12)' }
                    },
                    yRight: {
                        type: 'linear',
                        position: 'right',
                        beginAtZero: true,
                        suggestedMax: elementDataLeft['P'].filter(v => v !== null).length > 0 ? 
                                      1.1 * Math.max(...elementDataLeft['P'].filter(v => v !== null)) : 0.2,
                        ticks: { font: { family: 'Oswald', size: 14 } },
                        grid: { drawOnChartArea: false }
                    }
                },
                interaction: { mode: 'nearest', axis: 'x', intersect: false },
                plugins: {
                    title: { display: false, text: 'Nutrition', font: { family: 'Oswald', size: 14 }, align: 'start' },
                    legend: { display: true, position: 'top'},
                    tooltip: {
                        enabled: true, mode: 'index', intersect: false, bodyFont: { family: 'Oswald', size: 14 },
                        callbacks: {
                            label: function(context) {
                                const key = context.dataset.label === 'Nitrate' ? 'N' : 'P';
                                const value = context.parsed.y;
                                let formattedValue = 'N/A';

                                if (value !== null) {
                                    switch (key) {
                                        case 'Nitrate': // N
                                            formattedValue = value.toFixed(1);
                                            break;
                                        case 'Phosphate': // P
                                            formattedValue = value.toFixed(2);
                                            break;
                                        default:
                                            formattedValue = value.toString();
                                    }
                                }

                                return `${context.dataset.label}: ${formattedValue}`;
                            }
                        }
                    }
                }
            }
        });

        // Right chart
        const myChartRight = new Chart(ctxRight, {
            type: 'bar', // Default type for this chart
            data: {
                labels: labels,
                datasets: datasetsRight
            },
            options: {
                responsive: true,
                maintainAspectRatio: false, // Allow CSS to control height
                scales: {
                    x: {
                        stacked: true, // Enable stacking for bars on x-axis
                        ticks: { font: { family: 'Oswald', size: 13 } },
                        grid: { drawTicks: false, drawOnChartArea: true, drawBorder: true, color: 'rgba(180,180,180,0.12)' }
                    },
                    yLeft: { // For KH (Alk)
                        type: 'linear',
                        position: 'left',
                        beginAtZero: false, // Alk might not start at zero
                        suggestedMax: elementDataRight['KH'].filter(v => v !== null).length > 0 ? 
                                      1.05 * Math.max(...elementDataRight['KH'].filter(v => v !== null)) : 10,
                        ticks: { font: { family: 'Oswald', size: 14 } },
                        grid: { color: 'rgba(180,180,180,0.12)' }
                    },
                    yRight: { // For CA, MG (stacked bars)
                        type: 'linear',
                        position: 'right',
                        beginAtZero: true,
                        stacked: false, // y-axis itself is not stacked, individual datasets are
                        suggestedMax: Math.max(
                            elementDataRight['CA'].filter(v => v !== null).length > 0 ? Math.max(...elementDataRight['CA'].filter(v => v !== null)) : 0,
                            elementDataRight['MG'].filter(v => v !== null).length > 0 ? Math.max(...elementDataRight['MG'].filter(v => v !== null)) : 0
                        ) * 1.1, // Adjusted max for stacked bars
                        ticks: { font: { family: 'Oswald', size: 14 } },
                        grid: { drawOnChartArea: false }
                    }
                },
                interaction: { mode: 'nearest', axis: 'x', intersect: false },
                plugins: {
                    title: { display: false, text: 'Huge Elements', font: { family: 'Oswald', size: 14 }, align: 'top' },
                    legend: { display: true, position: 'top' },
                    tooltip: {
                        enabled: true, mode: 'index', intersect: false, bodyFont: { family: 'Oswald', size: 14 },
                        callbacks: {
                            label: function(context) {
                                // Map label to original key
                                const labelMap = { 'Calcium': 'CA', 'Magnesium': 'MG', 'Alk': 'KH' };
                                const key = labelMap[context.dataset.label] || context.dataset.label;
                                const value = context.parsed.y;
                                let formattedValue = 'N/A';

                                if (value !== null) {
                                    switch (key) {
                                        case 'Calcium': // CA
                                            formattedValue = value.toFixed(0);
                                            break;
                                        case 'Magnesium': // MG
                                            formattedValue = value.toFixed(0);
                                            break;
                                        case 'Alk': // KH
                                            formattedValue = value.toFixed(1);
                                            break;
                                        default:
                                            formattedValue = value.toString();
                                    }
                                }

                                return `${context.dataset.label}: ${formattedValue}`;
                            }
                        }
                    }
                }
            }
        });

        // Dynamically update element values for the elements list
        const elements = {
            nElement: 'N',
            pElement: 'P',
            caElement: 'CA',
            mgElement: 'MG',
            khElement: 'KH',
            orpElement: 'ORP',
            phElement: 'PH',
            tempElement: 'T'
        };

        // Get latest week label
        const latestWeek = labels.length > 0 ? labels[labels.length - 1] : null;
        // Helper to get latest value from weekMap for a key
        function getLatestWeekValue(key) {
            if (!latestWeek || !weekMap[latestWeek] || !weekMap[latestWeek][key]) return null;
            const arr = weekMap[latestWeek][key];
            if (!arr || arr.length === 0) return null;
            // Use the last value in the array for the week
            return arr[arr.length - 1];
        }
        // Helper to get latest value from realtimeData for a key
        function getLatestRealtimeValue(key) {
            for (let i = 0; i < realtimeData.length; i++) {
                const v = realtimeData[i][key];
                if (v !== undefined && v !== null) return v;
            }
            return null;
        }

        // Update values in the elements list
        Object.keys(elements).forEach(id => {
            const element = document.getElementById(id);
            const key = elements[id];
            let value = '-';

            if (["N","P","CA","MG","KH"].includes(key)) {
                const v = getLatestWeekValue(key);
                value = v !== null && v !== undefined ? v : '-';
            } else {
                const v = getLatestRealtimeValue(key);
                value = v !== null && v !== undefined ? v : '-';
                // Only show ORP/PH/Temperature if there is a value
                element.style.display = (value !== '-') ? 'list-item' : 'none';
            }

            element.querySelector('span').textContent += value;
        });

        // --- Update Elements List with Data ---
        // Define max values for percentage calculation
        const MAX_VALUES = {
            N: 2,    // Nitrate max for bar (e.g., 20 ppm)
            P: 0.03,   // Phosphate max for bar (e.g., 0.2 ppm)
            CA: 400,  // Calcium max for bar (e.g., 500 ppm)
            MG: 1320, // Magnesium max for bar (e.g., 1500 ppm)
            KH: 8,   // Alkalinity max for bar (e.g., 12 dKH)
            ORP: 380, // ORP max for bar (e.g., 450 mV)
            PH: 8,  // PH max for bar (e.g., 8.5)
            T: 24  // Temperature max for bar (e.g., 82 F)
        };

        function updateElementsList() {
            // Get the latest data for PH, ORP, Temp from realtimeData
            const latestRealtimeData = realtimeData.length > 0 ? realtimeData[0] : null;

            // Get the latest averaged data for N, P, CA, MG, KH from chart_data (weekly average)
            // This is a simplification; ideally, you'd have a separate "latest" data source for these.
            // For now, we'll use the last week's average from chart_data.
            const latestWeeklyData = labels.length > 0 ? rawData.find(d => getWeekStart(d.date) === labels[labels.length - 1]) : null;

            const elementsToUpdate = { 
                N: { id: 'nElement', name: 'Nitrate (N):', value: latestWeeklyData ? latestWeeklyData.N : null, decimals: 1 },
                P: { id: 'pElement', value: latestWeeklyData ? latestWeeklyData.P : null, decimals: 2 },
                CA: { id: 'caElement', value: latestWeeklyData ? latestWeeklyData.CA : null, decimals: 0 },
                MG: { id: 'mgElement', value: latestWeeklyData ? latestWeeklyData.MG : null, decimals: 0 },
                KH: { id: 'khElement', value: latestWeeklyData ? latestWeeklyData.KH : null, decimals: 1 },
                ORP: { id: 'orpElement', value: latestRealtimeData ? latestRealtimeData.ORP : null, decimals: 0 },
                PH: { id: 'phElement', value: latestRealtimeData ? latestRealtimeData.PH : null, decimals: 1 },
                T: { id: 'tempElement', value: latestRealtimeData ? latestRealtimeData.T : null, decimals: 1 } // Use 'T' for temperature
            };

            const BAR_FULL_AT = 0.7; // 70% of max is 100% for the bar
            for (const key in elementsToUpdate) {
                const elementInfo = elementsToUpdate[key];
                const listItem = document.getElementById(elementInfo.id);
                if (listItem) {
                    const percentageSpan = listItem.querySelector('.element-percentage');
                    const progressBarFill = listItem.querySelector('.progress-bar-fill');
                    const value = elementInfo.value;
                    const maxValue = MAX_VALUES[key];

                    if (value !== null && typeof value === 'number') {
                        let per_show = (value / (maxValue)) * 100;
                        let percentage = per_show * BAR_FULL_AT;
                        percentageSpan.textContent = `${per_show.toFixed(0)}%`;
                        progressBarFill.style.width = `${percentage}%`;
                        progressBarFill.style.backgroundColor = COLORS[key.toLowerCase()];
                        // Set color by range
                        if (per_show < 50) {
                            percentageSpan.style.color = '#a259e6'; // purple
                        } else if (per_show < 80) {
                            percentageSpan.style.color = '#3b82f6'; // blue
                        } else if (per_show < 120) {
                            percentageSpan.style.color = '#22c55e'; // green
                        } else if (per_show < 150) {
                            percentageSpan.style.color = '#facc15'; // yellow
                        } else {
                            percentageSpan.style.color = '#ef4444'; // red
                        }
                    } else {
                        percentageSpan.textContent = 'N/A';
                        percentageSpan.style.color = '#333';
                        progressBarFill.style.width = '0%';
                        progressBarFill.style.backgroundColor = '#e0e0e0';
                    }
                }
            }
        }

        // Call update function after charts are initialized or data is loaded
        updateElementsList();
    </script>
</body>
</html>