<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Reefing Memory</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css?family=Oswald:300,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Base styles for all screen sizes (Mobile-First Approach) */
        body {
            background: #f3f1f1;
            min-height: 100vh; /* Use min-height to allow content to extend beyond viewport */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align items to start on mobile for better scrolling */
        }

        /* Main container for all charts */
        .charts-container {
            width: 100%;
            min-height: 80vh;
            margin: 4px auto;
            padding: 4px 8px;
            display: flex;
            flex-direction: column; /* Default: stack all charts vertically on mobile */
            gap: 8px;
        }

        /* Individual chart card styles */
        .chart-card {
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0; /* Prevent cards from shrinking below content */
        }

        /* Heights for canvases on mobile (default) */
        #realtimeChart {
            width: 100%;
            height: 30vh; /* Adjusted height for mobile display */
        }
        #staticChartLeft,
        #staticChartRight {
            width: 100%;
            height: 23vh; /* Adjusted height for mobile display */
        }

        /* Wrapper for the two bottom charts (default stacked on mobile) */
        .bottom-charts-wrapper {
            display: flex;
            flex-direction: column; /* Stack these two charts vertically on mobile */
            gap: 8px;
            flex-grow: 1; /* Allow wrapper to grow if space permits */
        }

        /* --- Desktop Layout (min-width: 768px) --- */
        @media (min-width: 768px) {
            body {
                align-items: center; /* Center vertically on desktop */
            }

            .charts-container {
                /* On desktop, main container still stacks vertically (top chart, then wrapper) */
                flex-direction: column;
                min-height: 80vh; /* Ensure consistent min-height */
            }

            /* Desktop heights for canvases */
            #realtimeChart {
                height: 56vh; /* Taller on desktop */
            }
            #staticChartLeft,
            #staticChartRight {
                height: 36vh; /* Consistent height on desktop */
            }

            .bottom-charts-wrapper {
                flex-direction: row; /* Arrange the two bottom charts horizontally on desktop */
                flex-grow: 1; /* Allow wrapper to grow to fill space */
                align-items: stretch; /* Ensure bottom charts have same height */
            }

            .bottom-charts-wrapper > .chart-card {
                flex: 1; /* Each bottom chart takes equal width */
            }
        }
    </style>
</head>
<body>
    <div class="charts-container">
        <div class="chart-card">
            <canvas id="realtimeChart"></canvas>
        </div>

        <div class="bottom-charts-wrapper">
            <div class="chart-card">
                <canvas id="staticChartLeft"></canvas>
            </div>
            <div class="chart-card">
                <canvas id="staticChartRight"></canvas>
            </div>
        </div>
    </div>
    <script>
        // Placeholder for your Jinja2 variables.
        // In a real Flask/Jinja2 app, these would be populated server-side.
        const realtimeData = {{ realtime_data|tojson }} || [];
        const chart_data = {{ chart_data|tojson }} || [];

        // Check if realtimeData is empty and hide the chart if true
        if (!realtimeData || realtimeData.length === 0) {
            const realtimeChartContainer = document.getElementById('realtimeChart').parentElement;
            realtimeChartContainer.style.display = 'none';
        }

        // Group realtimeData by hour and average PH/ORP for each hour
        function getHour(ts) {
            // Assumes ts format 'YYYY-MM-DD HH:MM:SS' or 'YYYY-MM-DD HH:MM:SS.000Z' (ISO String)
            // We want 'YYYY-MM-DD HH:00'
            if (!ts) return '';
            let dateObj;
            if (ts.endsWith('Z')) { // It's an ISO string (UTC), convert to local date for consistent hour extraction
                dateObj = new Date(ts);
            } else { // Assume it's a local time string or needs parsing
                // For 'YYYY-MM-DD HH:MM:SS' or 'YYYY-MM-DD HH:MM', parse it directly.
                // NOTE: Parsing date strings without Z or timezone can be problematic cross-browser.
                // If 'time' from realtimeData is always a local time, this is okay.
                // If it's mixed, consider parsing it as UTC first: new Date(ts + 'Z') or specific parsing library.
                dateObj = new Date(ts.replace(' ', 'T')); // Convert to ISO-like format for safer parsing
            }

            const year = dateObj.getFullYear();
            const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
            const day = dateObj.getDate().toString().padStart(2, '0');
            const hour = dateObj.getHours().toString().padStart(2, '0');

            return `${year}-${month}-${day} ${hour}:00`;
        }

        const hourMap = {};
        realtimeData.forEach(d => {
            const hour = getHour(d.time); // Use the corrected getHour
            if (!hourMap[hour]) hourMap[hour] = { PH: [], ORP: [] };
            if (typeof d.PH === 'number') hourMap[hour].PH.push(d.PH);
            if (typeof d.ORP === 'number') hourMap[hour].ORP.push(d.ORP);
        });

        // 获取最近10天所有30分钟点
        function getRecentHalfHours(days) {
            const result = [];
            const now = new Date(); // Current local time
            // Loop from oldest day (days-1) to current day (0)
            for (let d = days - 1; d >= 0; d--) {
                let date = new Date(now);
                date.setDate(now.getDate() - d); // Set to the target day
                
                for (let h = 0; h < 24; h++) {
                    for (let m = 0; m < 60; m += 30) {
                        let dt = new Date(date); // Create new Date object for each time point
                        dt.setHours(h, m, 0, 0); // Set hour, minute, second, millisecond

                        // Only add if the generated time is not in the future
                        if (dt <= now) {
                            result.push(dt);
                        } else {
                            // If we've passed the current time, no need to generate further points for this day
                            break; 
                        }
                    }
                }
            }
            return result;
        }

        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const hourObjs = isMobile ? getRecentHalfHours(5) : getRecentHalfHours(7); // Adjusted for mobile devices
        
        // Formats labels for X-axis (e.g., "Jul 28 09:30")
        const dateLabels = hourObjs.map(dt => dt.toLocaleString(navigator.language, { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true }));

        // findValueForHour function (already corrected in previous turn)
        function findValueForHour(dt, key) {
            // dt: Date object, key: 'PH' or 'ORP'
            // target: 'YYYY-MM-DD HH:MM'

            // Extract parts of the Date object in local timezone
            const year = dt.getFullYear();
            const month = (dt.getMonth() + 1).toString().padStart(2, '0'); // getMonth() is 0-indexed
            const day = dt.getDate().toString().padStart(2, '0');
            const hours = dt.getHours().toString().padStart(2, '0');
            const minutes = dt.getMinutes().toString().padStart(2, '0'); 

            // This creates the exact format 'YYYY-MM-DD HH:MM' using local time values
            const ymdhm = `${year}-${month}-${day} ${hours}:${minutes}`;

            for (let i = 0; i < realtimeData.length; i++) {
                const t = realtimeData[i].time;
                // Check if realtimeData[i].time starts with our generated local time string
                // Assuming realtimeData[i].time is also in local time or can be compared this way
                if (t && t.startsWith(ymdhm)) {
                    return typeof realtimeData[i][key] === 'number' ? realtimeData[i][key] : null;
                }
            }
            return null; // Return null if no match is found
        }
        
        const phHourValues = hourObjs.map(dt => findValueForHour(dt, 'PH'));
        const orpHourValues = hourObjs.map(dt => findValueForHour(dt, 'ORP'));

        const realtimeElem = document.getElementById('realtimeChart');
        let lastLabel = ""; // Renamed from lastLabel to be more specific (lastDayLabel) for X-axis callback

        // Unified color constants
        const COLORS = {
            ph: 'rgba(255, 159, 64, 0.24)',  // Orange
            orp: 'rgba(54, 162, 235, 1)', // Blue
            n: 'rgba(75, 192, 192, 1)',   // Teal
            p: 'rgba(255, 99, 132, 1)',   // Red
            ca: 'rgba(255, 206, 86, 1)',  // Yellow
            mg: 'rgba(128, 128, 128, 0.12)', // Gray (changed from transparent for better visibility)
            kh: 'rgba(153, 102, 255, 1)', // Purple
            t: 'rgba(0, 200, 80, 1)',     // Green (used for temp, but not in current charts)
        }; 

        const skipped = (ctx, value) => ctx.p0.skip || ctx.p1.skip ? value : undefined;

        const realtimeChart = new Chart(realtimeElem.getContext('2d'), {
            type: 'line',
            data: {
                labels: dateLabels,
                datasets: [
                    {
                        label: 'PH',
                        data: phHourValues,
                        borderColor: COLORS.ph,
                        backgroundColor: COLORS.ph.replace('1)', '0.2)'), // Add transparency for fill color
                        fill: true, // Enable area fill
                        tension: 0.4,
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        yAxisID: 'yLeft',
                        spanGaps: true, // Connect null points
                        segment: {
                            borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                            borderDash: ctx => skipped(ctx, [6, 6]),
                        }
                    },
                    {
                        label: 'ORP',
                        data: orpHourValues,
                        borderColor: COLORS.orp,
                        backgroundColor: COLORS.orp.replace('1)', '0.2)'),
                        fill: false, // Do not fill area for ORP
                        tension: 0.4,
                        borderWidth: 3,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        yAxisID: 'yRight',
                        spanGaps: true, // Connect null points
                        segment: {
                            borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                            borderDash: ctx => skipped(ctx, [6, 6]),
                        }
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false, // Allow CSS to control height
                interaction: {
                    mode: 'index',
                    axis: 'x',
                    intersect: false
                },
                scales: {
                    x: {
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 12
                            },
                            autoSkip: false, // We control skipping manually
                            callback: function(value, index, ticks) {
                                // Get the full label string (e.g., "Jul 28 12:00 AM")
                                const fullLabel = this.getLabelForValue(value);
                                // Extract just the date part (e.g., "Jul 28")
                                const datePart = fullLabel.split(' ')[0] + ' ' + fullLabel.split(' ')[1];
                                
                                // Only display label if it's 12 AM (midnight) for a new day
                                // and if the date part hasn't been displayed before
                                if (fullLabel.includes('12 AM') && datePart !== lastLabel) {
                                    lastLabel = datePart; // Update last displayed date
                                    return datePart;
                                } 
                                return ''; // Hide other labels
                            }
                        },
                        grid: {
                            lineWidth: function(context) {
                                // Draw a grid line only at the start of a new day (every 48 half-hour points)
                                // hourObjs are 0-indexed, so 0, 48, 96 etc will be 12 AM of each day.
                                const dt = hourObjs[context.index];
                                if (dt && dt.getHours() === 0 && dt.getMinutes() === 0) {
                                     return 1;
                                }
                                return 0;
                            },
                            color: 'rgba(180,180,180,0.12)',
                            drawTicks: false,
                            drawOnChartArea: true,
                            drawBorder: true
                        }
                    },
                    yLeft: {
                        type: 'linear',
                        position: 'left',
                        beginAtZero: false,
                        // Calculate suggestedMax based on actual filtered values
                        suggestedMax: phHourValues.filter(v => v !== null).length > 0 ? 
                                      1.2 * Math.max(...phHourValues.filter(v => v !== null)) : 10,
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 14
                            }
                        },
                        grid: {
                            color: 'rgba(180,180,180,0.12)'
                        }
                    },
                    yRight: {
                        type: 'linear',
                        position: 'right',
                        beginAtZero: false,
                        // Calculate suggestedMax based on actual filtered values
                        suggestedMax: orpHourValues.filter(v => v !== null).length > 0 ?
                                      1.002 * Math.max(...orpHourValues.filter(v => v !== null)) : 500,
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 14
                            },
                            callback: function(value) {
                                return value.toFixed(0); // Show ORP as whole numbers
                            }
                        },
                        grid: {
                            drawOnChartArea: false // Hide horizontal grid lines for right Y-axis
                        }
                    }
                },
                plugins: {
                    title: {
                        display: false,
                        text: 'Real Time Tracking',
                        font: { family: 'Oswald', size: 14 },
                        align: 'top'
                    },
                    legend: {
                        display: true,
                        position: 'top',
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'index',
                        intersect: false,
                        bodyFont: { family: 'Oswald', size: 14 },
                        callbacks: {
                            title: function(context) {
                                // context[0] is the hovered item
                                const idx = context[0].dataIndex;
                                const dt = hourObjs[idx]; // Get the original Date object
                                
                                if (dt instanceof Date) {
                                    // Use toLocaleString for a user-friendly timestamp in their locale
                                    return dt.toLocaleString(navigator.language, { 
                                        month: 'short', 
                                        day: 'numeric', 
                                        hour: '2-digit', 
                                        minute: '2-digit', 
                                        hour12: true 
                                    });
                                }
                                return '';
                            },
                            label: function(context) {
                                const key = context.dataset.label;
                                const value = context.parsed.y;
                                let formattedValue = 'N/A';

                                if (value !== null) {
                                    switch (key) {
                                        case 'Nitrate': // N
                                            formattedValue = value.toFixed(1);
                                            break;
                                        case 'Phosphate': // P
                                            formattedValue = value.toFixed(2);
                                            break;
                                        case 'Calcium': // CA
                                            formattedValue = value.toFixed(0);
                                            break;
                                        case 'Magnesium': // MG
                                            formattedValue = value.toFixed(0);
                                            break;
                                        case 'Alk': // KH
                                            formattedValue = value.toFixed(1);
                                            break;
                                        case 'ORP':
                                            formattedValue = value.toFixed(0);
                                            break;
                                        case 'PH':
                                            formattedValue = value.toFixed(1);
                                            break;
                                        default:
                                            formattedValue = value.toString();
                                    }
                                }

                                return `${key}: ${formattedValue}`;
                            }
                        }
                    }
                }
            }
        });

        const rawData = {{ chart_data|tojson }} || [];
        const chartElem = document.getElementById('staticChartLeft');
        const chartRightElem = document.getElementById('staticChartRight');
        
        const ctx = chartElem.getContext('2d');
        const ctxRight = chartRightElem.getContext('2d');

        const colorPalette = [
            COLORS.n, // Nitrate (Teal)
            COLORS.p, // Phosphate (Red)
            COLORS.ca, // Calcium (Yellow)
            COLORS.mg, // Magnesium (Gray)
            COLORS.kh, // Alkalinity (Purple)
        ];

        // Helper to get week start from date string (assumes format like "Mon DD" or 'YYYY-MM-DD')
        // We'll try to parse it more robustly
        function getWeekStart(dateStr) {
            // First, try to parse as ISO-like, then get the date
            let d;
            if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) { // YYYY-MM-DD format
                d = new Date(dateStr + 'T00:00:00'); // Ensure it's treated as a local date
            } else { // Assume it's "Mon DD"
                d = new Date(dateStr + ', ' + new Date().getFullYear()); // Add current year for parsing
            }
            
            const dayOfWeek = d.getDay(); // 0 for Sunday, 1 for Monday, ..., 6 for Saturday
            const diff = d.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); // Adjust to Monday of the current week (or previous if Sunday)
            const monday = new Date(d.setDate(diff));
            
            // Format to "Mon DD" for labels
            return monday.toLocaleDateString(navigator.language, { month: 'short', day: 'numeric' });
        }

        // Group all entries by week
        const weekMap = {};
        rawData.forEach(d => {
            const week = getWeekStart(d.date);
            if (!weekMap[week]) weekMap[week] = {};
            ['N','P','CA','MG','KH'].forEach(key => {
                if (typeof d[key] === 'number') { // Only push if it's a number
                    if (!weekMap[week][key]) weekMap[week][key] = [];
                    weekMap[week][key].push(d[key]);
                }
            });
        });

        // Aggregate values for each week (average)
        function avg(arr) {
            if (!arr || arr.length === 0) return null;
            return parseFloat((arr.reduce((a,b) => a+b,0) / arr.length).toFixed(2));
        }

        const labels = Object.keys(weekMap).sort((a,b) => {
            // Custom sort for "Mon DD" format
            const dateA = new Date(a + ', ' + new Date().getFullYear());
            const dateB = new Date(b + ', ' + new Date().getFullYear());
            return dateA - dateB;
        });

        const elementKeys = ['N', 'P']; // Left Chart Elements
        const elementData = {};  
        elementKeys.forEach(key => {
            elementData[key] = labels.map(week => {
                const arr = weekMap[week][key];
                return arr ? avg(arr) : null;
            });
        });

        const elementKeysRight = ['CA', 'MG', 'KH']; // Right Chart Elements
        const elementDataRight = {};
        elementKeysRight.forEach(key => {
            elementDataRight[key] = labels.map(week => {
                const arr = weekMap[week][key];
                return arr ? avg(arr) : null;
            });
        });

        // Assign yAxisID: No3 on left, Po4 on right for the left chart
        function getAxisLeftChart(key) {
            return key === 'N' ? 'yLeft' : 'yRight';
        }
        const datasetsLeft = elementKeys.map((key, idx) => ({
            label: key === 'N' ? 'Nitrate' : 'Phosphate', // Assuming only N and P here
            data: elementData[key],
            borderColor: COLORS[key.toLowerCase()], // Use predefined colors
            backgroundColor: COLORS[key.toLowerCase()].replace('1)', '0.2)'),
            fill: true,
            tension: 0.4,
            borderWidth: 2,
            pointRadius: 0,
            pointHoverRadius: 6,
            yAxisID: getAxisLeftChart(key),
            spanGaps: true,
            segment: {
                borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                borderDash: ctx => skipped(ctx, [6, 6]),
            }
        }));

        // Right chart: CA and MG as stacked bars, KH as line
        function getAxisRightChart(key) {
            // CA and MG might share one axis (right), KH on another (left)
            return key === 'KH' ? 'yLeft' : 'yRight';
        }
        const datasetsRight = elementKeysRight.map((key, idx) => {
            const baseColor = colorPalette[(idx + 2) % colorPalette.length]; // Re-use color palette or define more
            if (key === 'MG' || key === 'CA') {
                return {
                    label: key === 'MG' ? 'Magnesium' : 'Calcium',
                    data: elementDataRight[key],
                    backgroundColor: COLORS[key.toLowerCase()],
                    type: 'bar',
                    stack: 'elementsStack', // All bars that should stack use the same stack ID
                    yAxisID: getAxisRightChart(key),
                    order: 1,
                    segment: {
                        borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                        borderDash: ctx => skipped(ctx, [6, 6]),
                    }
                };
            } else { // KH
                return {
                    label: 'Alk', // Label for KH
                    data: elementDataRight[key],
                    borderColor: COLORS.kh,
                    backgroundColor: COLORS.kh.replace('1)', '0.2)'),
                    fill: false,
                    type: 'line',
                    tension: 0.4,
                    borderWidth: 2,
                    pointRadius: 0,
                    pointHoverRadius: 6,
                    yAxisID: getAxisRightChart(key),
                    spanGaps: true,
                    order: 0,
                    segment: {
                        borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                        borderDash: ctx => skipped(ctx, [6, 6]),
                    }
                };
            }
        });

        const myChartLeft = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasetsLeft
            },
            options: {
                responsive: true,
                maintainAspectRatio: false, // Allow CSS to control height
                scales: {
                    x: {
                        ticks: {
                            font: { family: 'Oswald', size: 13 },
                            // Improve X-axis label display for weeks
                            callback: function(value, index, ticks) {
                                // Only display every X labels if too many, or always if few
                                return this.getLabelForValue(value);
                            }
                        },
                        grid: {
                            drawTicks: false,
                            drawOnChartArea: true,
                            drawBorder: true,
                            color: 'rgba(180,180,180,0.12)'
                        }
                    },
                    yLeft: {
                        type: 'linear',
                        position: 'left',
                        beginAtZero: true,
                        suggestedMax: elementData['N'].filter(v => v !== null).length > 0 ? 
                                      1.3 * Math.max(...elementData['N'].filter(v => v !== null)) : 10,
                        ticks: { font: { family: 'Oswald', size: 14 } },
                        grid: { color: 'rgba(180,180,180,0.12)' }
                    },
                    yRight: {
                        type: 'linear',
                        position: 'right',
                        beginAtZero: true,
                        suggestedMax: elementData['P'].filter(v => v !== null).length > 0 ? 
                                      1.1 * Math.max(...elementData['P'].filter(v => v !== null)) : 0.2,
                        ticks: { font: { family: 'Oswald', size: 14 } },
                        grid: { drawOnChartArea: false }
                    }
                },
                interaction: { mode: 'nearest', axis: 'x', intersect: false },
                plugins: {
                    title: { display: false, text: 'Nutrition', font: { family: 'Oswald', size: 14 }, align: 'start' },
                    legend: { display: true, position: 'top' },
                    tooltip: {
                        enabled: true, mode: 'index', intersect: false, bodyFont: { family: 'Oswald', size: 14 },
                        callbacks: {
                            label: function(context) {
                                const key = context.dataset.label === 'Nitrate' ? 'N' : 'P';
                                const value = context.parsed.y;
                                let formattedValue = 'N/A';

                                if (value !== null) {
                                    switch (key) {
                                        case 'Nitrate': // N
                                            formattedValue = value.toFixed(1);
                                            break;
                                        case 'Phosphate': // P
                                            formattedValue = value.toFixed(2);
                                            break;
                                        default:
                                            formattedValue = value.toString();
                                    }
                                }

                                return `${context.dataset.label}: ${formattedValue}`;
                            }
                        }
                    }
                }
            }
        });

        // Right chart
        const myChartRight = new Chart(ctxRight, {
            type: 'bar', // Default type for this chart
            data: {
                labels: labels,
                datasets: datasetsRight
            },
            options: {
                responsive: true,
                maintainAspectRatio: false, // Allow CSS to control height
                scales: {
                    x: {
                        stacked: true, // Enable stacking for bars on x-axis
                        ticks: { font: { family: 'Oswald', size: 13 } },
                        grid: { drawTicks: false, drawOnChartArea: true, drawBorder: true, color: 'rgba(180,180,180,0.12)' }
                    },
                    yLeft: { // For KH (Alk)
                        type: 'linear',
                        position: 'left',
                        beginAtZero: false, // Alk might not start at zero
                        suggestedMax: elementDataRight['KH'].filter(v => v !== null).length > 0 ? 
                                      1.05 * Math.max(...elementDataRight['KH'].filter(v => v !== null)) : 10,
                        ticks: { font: { family: 'Oswald', size: 14 } },
                        grid: { color: 'rgba(180,180,180,0.12)' }
                    },
                    yRight: { // For CA, MG (stacked bars)
                        type: 'linear',
                        position: 'right',
                        beginAtZero: true,
                        stacked: false, // y-axis itself is not stacked, individual datasets are
                        suggestedMax: Math.max(
                            elementDataRight['CA'].filter(v => v !== null).length > 0 ? Math.max(...elementDataRight['CA'].filter(v => v !== null)) : 0,
                            elementDataRight['MG'].filter(v => v !== null).length > 0 ? Math.max(...elementDataRight['MG'].filter(v => v !== null)) : 0
                        ) * 1.1, // Adjusted max for stacked bars
                        ticks: { font: { family: 'Oswald', size: 14 } },
                        grid: { drawOnChartArea: false }
                    }
                },
                interaction: { mode: 'nearest', axis: 'x', intersect: false },
                plugins: {
                    title: { display: false, text: 'Huge Elements', font: { family: 'Oswald', size: 14 }, align: 'top' },
                    legend: { display: true, position: 'top' },
                    tooltip: {
                        enabled: true, mode: 'index', intersect: false, bodyFont: { family: 'Oswald', size: 14 },
                        callbacks: {
                            label: function(context) {
                                // Map label to original key
                                const labelMap = { 'Calcium': 'CA', 'Magnesium': 'MG', 'Alk': 'KH' };
                                const key = labelMap[context.dataset.label] || context.dataset.label;
                                const value = context.parsed.y;
                                let formattedValue = 'N/A';

                                if (value !== null) {
                                    switch (key) {
                                        case 'Nitrate': // N
                                            formattedValue = value.toFixed(1);
                                            break;
                                        case 'Phosphate': // P
                                            formattedValue = value.toFixed(2);
                                            break;
                                        case 'Calcium': // CA
                                            formattedValue = value.toFixed(0);
                                            break;
                                        case 'Magnesium': // MG
                                            formattedValue = value.toFixed(0);
                                            break;
                                        case 'Alk': // KH
                                            formattedValue = value.toFixed(1);
                                            break;
                                        default:
                                            formattedValue = value.toString();
                                    }
                                }

                                return `${context.dataset.label}: ${formattedValue}`;
                            }
                        }
                    }
                }
            }
        });
    </script>
</body>
</html>