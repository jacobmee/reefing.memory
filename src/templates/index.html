<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Reefing Memory</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css?family=Oswald:300,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Lato:300,700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Auto-refresh page every hour (3600000 ms)
        setTimeout(function() { window.location.reload(); }, 3600000);
    </script>
    <style>
        /* Base styles for all screen sizes (Mobile-First Approach) */
        body {
            background: #f3f1f1;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        /* Main container for all charts */
        .charts-container {
            width: 100%;
            min-height: 80vh;
            margin: 4px auto;
            padding: 4px 8px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* Individual chart card styles */
        .chart-card {
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            width: 100%;
            box-sizing: border-box;
        }

        /* Heights for canvases on mobile (default) */
        #realtimeChart {
            width: 100%;
            height: 30vh;
        }
        #staticChartLeft,
        #staticChartRight {
            width: 100%;
            height: 23vh;
        }

        /* Wrapper for the two bottom charts (default stacked on mobile) */
        .bottom-charts-wrapper {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-grow: 1;
            width: 100%;
        }

        /* New styles for the elements list section */
        .elements-list {
            background: #fff;
            padding: 25px;
            padding-top: 10px;
            border-radius: 4px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
            font-family: 'Oswald', sans-serif;
            font-size: 13px;
            flex-shrink: 0;
            width: 100%;
            box-sizing: border-box;
            /* --- START MOBILE HEIGHT ADJUSTMENT --- */
            min-height: 30vh; /* 设定一个最小高度，使其在手机上更高一些 */
            overflow-y: auto; /* 如果内容溢出，允许垂直滚动 */
        }
        .elements-list h4 {
            margin: 10px 0 24px 0;
            font-family: 'Lato', sans-serif;
            font-size: 23px;
            text-align: center;
            color: #333;
        }

        /* --- START OF CHANGES FOR MOBILE ELEMENTS LIST LAYOUT --- */
        .elements-list ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 8px 32px;
        }

        .elements-list li {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: calc(50% - 16px);
            margin-bottom: 0;
            box-sizing: border-box;
        }
        /* --- END OF CHANGES FOR MOBILE ELEMENTS LIST LAYOUT --- */

        .elements-list li:last-child {
            margin-bottom: 0;
        }

        .element-label-row {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 4px;
        }

        .element-label {
            font-weight: normal;
            color: #555;
        }

        .element-percentage {
            font-weight: bold;
            color: #333;
            min-width: 40px;
            text-align: right;
        }

        .progress-bar-container {
            width: 100%;
            height: 6px;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .progress-bar-threshold {
            position: absolute;
            left: 70%;
            top: 0;
            width: 2px;
            height: 100%;
            background: #888;
            opacity: 0.7;
            z-index: 2;
        }

        .progress-bar-fill {
            height: 100%;
            width: 0%;
            border-radius: 2px;
            transition: width 0.5s ease-in-out;
        }

        .top-section {
            display: flex;
            flex-direction: column; /* Mobile: stack vertically */
            align-items: flex-start;
            gap: 8px;
            width: 100%;
        }

        /* Order for mobile layout: elements-list first, then realtimeChart */
        .top-section .elements-list {
            order: 1;
        }

        .top-section .chart-card {
            order: 2;
        }


        /* --- Desktop Layout (min-width: 768px) --- */
        @media (min-width: 768px) {
            body {
                align-items: center;
            }

            .charts-container {
                flex-direction: column;
                min-height: 80vh;
            }

            #realtimeChart {
                width: 100%;
                height: 100%;
            }
            #staticChartLeft,
            #staticChartRight {
                height: 36vh;
            }

            .bottom-charts-wrapper {
                flex-direction: row;
                flex-grow: 1;
                align-items: stretch;
            }

            .bottom-charts-wrapper > .chart-card {
                flex: 1;
            }

            .top-section {
                flex-direction: row;
                align-items: stretch;
                height: 58vh;
            }

            /* Reset order for desktop */
            .top-section .elements-list {
                order: 0;
            }

            .top-section .chart-card {
                order: 0;
                flex-grow: 1;
            }

            .elements-list {
                width: 280px;
                flex-shrink: 0;
                flex-basis: 280px;
                /* 桌面视图下，min-height会被flexbox的拉伸行为覆盖 */
            }

            /* --- Desktop Specific Overrides for elements-list ul/li --- */
            .elements-list ul {
                display: block;
                gap: 0;
            }
            .elements-list li {
                width: 100%;
                margin-bottom: 9px;
            }
            .elements-list li:last-child {
                margin-bottom: 0;
            }
            /* --- END Desktop Specific Overrides --- */

            .chart-card {
                width: auto;
                flex-grow: 1;
            }
        }
    </style>
</head>
<body>
    <div class="charts-container">
        <div class="top-section">
            <div class="elements-list">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 18px;">
                    <h4 style="margin:0;">Reefing Memory</h4>
                    <button id="addEntryBtn" title="Add new entry" style="background: none; border: none; cursor: pointer; margin-left: 8px; color: #3b82f6; display: flex; align-items: center; justify-content: center; height: 1.6em; width: 1.6em; padding: 0;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#3b82f6" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="display:block;"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
                    </button>
                </div>
        <!-- Modal for adding new entry -->
        <div id="addEntryModal" style="display:none; position:fixed; z-index:1000; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.25); justify-content:center; align-items:center;">
            <div style="background:#fff; border-radius:8px; box-shadow:0 8px 32px rgba(0,0,0,0.18); padding:12px 24px 24px 24px; min-width:320px; max-width:95vw; position:relative;">
                <button id="closeAddEntryModal" style="position:absolute; top:12px; right:12px; background:none; border:none; font-size:1.5em; color:#888; cursor:pointer;">&times;</button>
                <h4>Element Entry</h4>
                <form id="addEntryForm" style="display:flex; flex-direction:column; gap:16px;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 8px;">
                        <button id="prevEntryBtn" type="button" title="Previous" style="background: none; border: none; cursor: pointer; color: #3b82f6; display: flex; align-items: center; justify-content: center; height: 1.6em; width: 1.6em; padding: 0;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#3b82f6" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="display:block;"><polyline points="15 18 9 12 15 6"/></svg>
                        </button>
                        <label for="entryDate" style="font-family:'Oswald',sans-serif; margin:0 4px 0 0;">Date:</label>
                        <input id="entryDate" name="date" type="date" required style="font-size:1em; padding:2px 8px; border-radius:4px; border:1px solid #ccc; font-family:'Oswald',sans-serif; min-width:120px; text-align:center;"/>
                        <button id="nextEntryBtn" type="button" title="Next" style="background: none; border: none; cursor: pointer; color: #3b82f6; display: flex; align-items: center; justify-content: center; height: 1.6em; width: 1.6em; padding: 0;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#3b82f6" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="display:block;"><polyline points="9 18 15 12 9 6"/></svg>
                        </button>
                    </div>
                    <ul id="modalElementList" style="list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:10px;">
                        <!-- JS will populate -->
                    </ul>
                    <button type="submit" style="margin-top:12px; background:#3b82f6; color:#fff; border:none; border-radius:4px; font-size:1.1em; padding:8px 0; cursor:pointer;">Save</button>
                </form>
            </div>
        </div>
                <ul>
                    <li id="orpElement">
                        <div class="element-label-row">
                            <span class="element-label">ORP: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="orp"></div>
                        </div>
                    </li>
                    <li id="phElement">
                        <div class="element-label-row">
                            <span class="element-label">PH: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="ph"></div>
                        </div>
                    </li>
                    <li id="tempElement">
                        <div class="element-label-row">
                            <span class="element-label">Temperature: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="t"></div>
                        </div>
                    </li>
                    <li id="nElement">
                        <div class="element-label-row">
                            <span class="element-label">Nitrate: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="n"></div>
                        </div>
                    </li>
                    <li id="pElement">
                        <div class="element-label-row">
                            <span class="element-label">Phosphate: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="p"></div>
                        </div>
                    </li>
                    <li id="caElement">
                        <div class="element-label-row">
                            <span class="element-label">Calcium: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="ca"></div>
                        </div>
                    </li>
                    <li id="mgElement">
                        <div class="element-label-row">
                            <span class="element-label">Magnesium: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="mg"></div>
                        </div>
                    </li>
                    <li id="khElement">
                        <div class="element-label-row">
                            <span class="element-label">Alkalinity: </span>
                            <span class="element-percentage"></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-threshold"></div>
                            <div class="progress-bar-fill" data-element="kh"></div>
                        </div>
                    </li>
                </ul>
            </div>

            <div class="chart-card">
                <canvas id="realtimeChart"></canvas>
            </div>
        </div>

        <div class="bottom-charts-wrapper">
            <div class="chart-card">
                <canvas id="staticChartLeft"></canvas>
            </div>
            <div class="chart-card">
                <canvas id="staticChartRight"></canvas>
            </div>
        </div>
    </div>
    <script>
        // --- Modal logic for adding new entry ---
        // 格式化 'Mon DD' 为 YYYY-MM-DD
        function formatDateYYYYMMDD(dateStr) {
            const d = new Date(dateStr + ', ' + new Date().getFullYear());
            const yyyy = d.getFullYear();
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
        }
        const addEntryBtn = document.getElementById('addEntryBtn');
        const addEntryModal = document.getElementById('addEntryModal');
        const closeAddEntryModal = document.getElementById('closeAddEntryModal');
        const addEntryForm = document.getElementById('addEntryForm');
        const modalElementList = document.getElementById('modalElementList');
        const entryDateInput = document.getElementById('entryDate');

        // Element keys and display names for modal
        const modalElements = [
            { key: 'N', label: 'Nitrate', min: 0, max: 20, decimals: 1 },
            { key: 'P', label: 'Phosphate', min: 0, max: 0.2, decimals: 2 },
            { key: 'CA', label: 'Calcium', min: 300, max: 500, decimals: 0 },
            { key: 'MG', label: 'Magnesium', min: 1000, max: 1600, decimals: 0 },
            { key: 'KH', label: 'Alkalinity', min: 4, max: 10, decimals: 1 }
        ];

        // --- Modal navigation state ---
        let modalEntryIndex = null; // null means latest

        // Drag and drop helpers
        let dragSrcEl = null;
        function handleDragStart(e) {
            dragSrcEl = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.outerHTML);
            this.classList.add('dragElem');
        }
        function handleDragOver(e) {
            if (e.preventDefault) e.preventDefault();
            this.classList.add('over');
            return false;
        }
        function handleDragLeave(e) {
            this.classList.remove('over');
        }
        function handleDrop(e) {
            if (e.stopPropagation) e.stopPropagation();
            if (dragSrcEl !== this) {
                this.parentNode.removeChild(dragSrcEl);
                const dropHTML = e.dataTransfer.getData('text/html');
                this.insertAdjacentHTML('beforebegin', dropHTML);
                const dropElem = this.previousSibling;
                addDnDHandlers(dropElem);
            }
            this.classList.remove('over');
            return false;
        }
        function handleDragEnd(e) {
            this.classList.remove('over');
            this.classList.remove('dragElem');
        }
        function addDnDHandlers(elem) {
            elem.addEventListener('dragstart', handleDragStart, false);
            elem.addEventListener('dragover', handleDragOver, false);
            elem.addEventListener('dragleave', handleDragLeave, false);
            elem.addEventListener('drop', handleDrop, false);
            elem.addEventListener('dragend', handleDragEnd, false);
        }

        function renderModalEntry(entry) {
            // entry: object with keys N, P, CA, MG, KH, date
            modalElementList.innerHTML = '';
            modalElements.forEach((el, idx) => {
                const li = document.createElement('li');
                li.setAttribute('draggable', 'true');
                li.style.display = 'flex';
                li.style.flexDirection = 'column';
                li.style.alignItems = 'flex-start';
                li.style.background = '#f3f1f1';
                li.style.borderRadius = '4px';
                li.style.padding = '8px 10px 10px 10px';
                li.style.marginBottom = '0';
                // Label row
                const labelRow = document.createElement('div');
                labelRow.style.display = 'flex';
                labelRow.style.justifyContent = 'space-between';
                labelRow.style.width = '100%';
                labelRow.style.marginBottom = '4px';
                const label = document.createElement('span');
                label.textContent = el.label + ': ';
                label.style.fontFamily = 'Oswald, sans-serif';
                label.style.color = '#555';
                const valueSpan = document.createElement('span');
                valueSpan.className = 'modal-element-value';
                valueSpan.style.fontWeight = 'bold';
                valueSpan.style.color = '#333';
                valueSpan.style.minWidth = '40px';
                valueSpan.style.textAlign = 'right';
                // Set value from entry, fallback to min
                let value = (entry && entry[el.key] != null) ? Number(entry[el.key]) : el.min;
                valueSpan.textContent = value.toFixed(el.decimals);
                labelRow.appendChild(label);
                labelRow.appendChild(valueSpan);
                // Progress bar
                const barContainer = document.createElement('div');
                barContainer.className = 'modal-progress-bar-container';
                barContainer.style.width = '100%';
                barContainer.style.height = '8px';
                barContainer.style.background = '#e0e0e0';
                barContainer.style.borderRadius = '4px';
                barContainer.style.position = 'relative';
                barContainer.style.overflow = 'hidden';
                barContainer.style.userSelect = 'none';
                barContainer.style.touchAction = 'none';
                // Threshold marker
                const threshold = document.createElement('div');
                threshold.className = 'progress-bar-threshold';
                threshold.style.position = 'absolute';
                threshold.style.left = '50%';
                threshold.style.top = '0';
                threshold.style.width = '2px';
                threshold.style.height = '100%';
                threshold.style.background = '#888';
                threshold.style.opacity = '0.5';
                threshold.style.zIndex = '2';
                barContainer.appendChild(threshold);
                // Fill
                const fill = document.createElement('div');
                fill.className = 'modal-progress-bar-fill';
                fill.style.height = '100%';
                fill.style.width = ((value - el.min) / (el.max - el.min) * 100) + '%';
                fill.style.borderRadius = '4px';
                fill.style.background = COLORS[el.key.toLowerCase()];
                fill.style.transition = 'width 0.2s';
                barContainer.appendChild(fill);
                // Drag/Click interaction
                function setValueFromBar(e) {
                    if (e.preventDefault) e.preventDefault();
                    const rect = barContainer.getBoundingClientRect();
                    const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
                    let percent = Math.max(0, Math.min(1, x / rect.width));
                    value = el.min + percent * (el.max - el.min);
                    // Snap to step
                    const step = Math.pow(10, -el.decimals);
                    value = Math.round(value / step) * step;
                    value = Math.max(el.min, Math.min(el.max, value));
                    valueSpan.textContent = value.toFixed(el.decimals);
                    fill.style.width = ((value - el.min) / (el.max - el.min) * 100) + '%';
                }
                barContainer.addEventListener('mousedown', function(e) {
                    setValueFromBar(e);
                    function moveHandler(ev) { setValueFromBar(ev); }
                    function upHandler() {
                        document.removeEventListener('mousemove', moveHandler);
                        document.removeEventListener('mouseup', upHandler);
                    }
                    document.addEventListener('mousemove', moveHandler);
                    document.addEventListener('mouseup', upHandler);
                });
                barContainer.addEventListener('touchstart', function(e) {
                    setValueFromBar(e);
                    function moveHandler(ev) { setValueFromBar(ev); }
                    function upHandler() {
                        document.removeEventListener('touchmove', moveHandler);
                        document.removeEventListener('touchend', upHandler);
                    }
                    document.addEventListener('touchmove', moveHandler);
                    document.addEventListener('touchend', upHandler);
                });
                // Store value on li for submit
                li.dataset.key = el.key;
                li.dataset.value = value;
                // Update value on change
                function updateValueOnBar() {
                    li.dataset.value = value;
                }
                barContainer.addEventListener('mouseup', updateValueOnBar);
                barContainer.addEventListener('touchend', updateValueOnBar);
                // Compose
                li.appendChild(labelRow);
                li.appendChild(barContainer);
                addDnDHandlers(li);
                modalElementList.appendChild(li);
            });
        }

        function openAddEntryModal() {
        // Always reset to 'add new' mode
        modalEntryIndex = null;
        const chartData = window.chart_data || [];
        // 默认数据：可选，使用最新一条数据作为初始值，否则用默认值
        let entry = null;
        if (chartData.length > 0) {
            entry = chartData[chartData.length - 1];
        }
        // 日期始终为今天
        const today = new Date();
        entryDateInput.value = today.toISOString().slice(0,10);
        renderModalEntry(entry);
        updateModalNavButtons();
        addEntryModal.style.display = 'flex';
        }

        function updateModalNavButtons() {
            const chartData = window.chart_data || [];
            const prevBtn = document.getElementById('prevEntryBtn');
            const nextBtn = document.getElementById('nextEntryBtn');
            // Always keep buttons in layout, just hide visually
            if (!chartData.length || chartData.length === 1) {
                prevBtn.style.visibility = 'hidden';
                nextBtn.style.visibility = 'hidden';
                return;
            }
            if (modalEntryIndex === null || modalEntryIndex === chartData.length - 1) {
                prevBtn.style.visibility = chartData.length > 1 ? 'visible' : 'hidden';
                nextBtn.style.visibility = 'hidden';
            } else if (modalEntryIndex === 0) {
                prevBtn.style.visibility = 'hidden';
                nextBtn.style.visibility = 'visible';
            } else {
                prevBtn.style.visibility = 'visible';
                nextBtn.style.visibility = 'visible';
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            const prevBtn = document.getElementById('prevEntryBtn');
            const nextBtn = document.getElementById('nextEntryBtn');
            prevBtn.addEventListener('click', function() {
                const chartData = window.chart_data || [];
                if (chartData.length < 2) return;
                if (modalEntryIndex === null) {
                    // Go to previous (second last)
                    modalEntryIndex = chartData.length - 2;
                } else if (modalEntryIndex > 0) {
                    modalEntryIndex--;
                }
                const entry = chartData[modalEntryIndex];
                // Set date input
                if (entry && entry.date) {
                    entryDateInput.value = formatDateYYYYMMDD(entry.date);
                }
                renderModalEntry(entry);
                updateModalNavButtons();
            });
            nextBtn.addEventListener('click', function() {
                const chartData = window.chart_data || [];
                if (chartData.length < 2) return;
                if (modalEntryIndex === null) return; // Already at latest
                if (modalEntryIndex < chartData.length - 1) {
                    modalEntryIndex++;
                }
                // If now at latest, set to null
                if (modalEntryIndex === chartData.length - 1) {
                    modalEntryIndex = null;
                    const entry = chartData[chartData.length - 1];
                    if (entry && entry.date) {
                        entryDateInput.value = formatDateYYYYMMDD(entry.date);
                    }
                    renderModalEntry(entry);
                } else {
                    const entry = chartData[modalEntryIndex];
                    if (entry && entry.date) {
                        entryDateInput.value = formatDateYYYYMMDD(entry.date);
                    }
                    renderModalEntry(entry);
                }
                updateModalNavButtons();
            });
        });
        function closeAddEntry() {
            addEntryModal.style.display = 'none';
        }
        addEntryBtn.addEventListener('click', openAddEntryModal);
        closeAddEntryModal.addEventListener('click', closeAddEntry);
        addEntryModal.addEventListener('click', function(e) {
            if (e.target === addEntryModal) closeAddEntry();
        });

        // Handle form submit
        addEntryForm.addEventListener('submit', function(e) {
            e.preventDefault();
            // Get date in 'Mon DD' format
            const dateVal = entryDateInput.value;
            const dateObj = new Date(dateVal);
            const month = dateObj.toLocaleString('en-US', { month: 'short' });
            const day = dateObj.getDate();
            const dateStr = `${month} ${day}`;
            // Get values in current order
            const values = {};
            Array.from(modalElementList.children).forEach(li => {
                const key = li.dataset.key;
                const value = parseFloat(li.querySelector('.modal-element-value').textContent);
                values[key] = value;
            });
            // Compose data
            const data = { date: dateStr, ...values };
            // Send to backend
            fetch('/add_static_data', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            .then(resp => resp.json())
            .then(resp => {
                if (resp.success) {
                    closeAddEntry();
                    window.location.reload();
                } else {
                    alert('Failed to save: ' + (resp.error || 'Unknown error'));
                }
            })
            .catch(() => alert('Failed to save.'));
        });
        // Placeholder for your Jinja2 variables.
        // In a real Flask/Jinja2 app, these would be populated server-side.
        const realtimeData = {{ realtime_data|tojson }} || [];
        const chart_data = {{ chart_data|tojson }} || [];
        window.chart_data = chart_data;

        // Check if realtimeData is empty and hide the chart if true
        if (!realtimeData || realtimeData.length === 0) {
            const realtimeChartContainer = document.getElementById('realtimeChart').parentElement;
            realtimeChartContainer.style.display = 'none';
        }

        // Group realtimeData by hour and average PH/ORP for each hour
        function getHour(ts) {
            // Assumes ts format 'YYYY-MM-DD HH:MM:SS' or 'YYYY-MM-DD HH:MM:SS.000Z' (ISO String)
            // We want 'YYYY-MM-DD HH:00'
            if (!ts) return '';
            let dateObj;
            if (ts.endsWith('Z')) { // It's an ISO string (UTC), convert to local date for consistent hour extraction
                dateObj = new Date(ts);
            } else { // Assume it's a local time string or needs parsing
                // For 'YYYY-MM-DD HH:MM:SS' or 'YYYY-MM-DD HH:MM', parse it directly.
                // NOTE: Parsing date strings without Z or timezone can be problematic cross-browser.
                // If 'time' from realtimeData is always a local time, this is okay.
                // If it's mixed, consider parsing it as UTC first: new Date(ts + 'Z') or specific parsing library.
                dateObj = new Date(ts.replace(' ', 'T')); // Convert to ISO-like format for safer parsing
            }

            const year = dateObj.getFullYear();
            const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
            const day = dateObj.getDate().toString().padStart(2, '0');
            const hour = dateObj.getHours().toString().padStart(2, '0');

            return `${year}-${month}-${day} ${hour}:00`;
        }

        const hourMap = {};
        realtimeData.forEach(d => {
            const hour = getHour(d.time); // Use the corrected getHour
            if (!hourMap[hour]) hourMap[hour] = { PH: [], ORP: [] };
            if (typeof d.PH === 'number') hourMap[hour].PH.push(d.PH);
            if (typeof d.ORP === 'number') hourMap[hour].ORP.push(d.ORP);
        });

        // 获取最近10天所有30分钟点
        function getRecentHalfHours(days) {
            const result = [];
            const now = new Date(); // Current local time
            // Loop from oldest day (days-1) to current day (0)
            for (let d = days - 1; d >= 0; d--) {
                let date = new Date(now);
                date.setDate(now.getDate() - d); // Set to the target day
                
                // Every 4 hours
                for (let h = 0; h < 24; h = h + 2) {
                    
                    let dt = new Date(date); // Create new Date object for each time point
                    dt.setHours(h, 0, 0, 0); // Set hour, minute, second, millisecond

                    // Only add if the generated time is not in the future
                    if (dt <= now) {
                        result.push(dt);
                    } else {
                        // If we've passed the current time, no need to generate further points for this day
                        break; 
                    }
                    
                }
            }
            return result;
        }

        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const hourObjs = isMobile ? getRecentHalfHours(5) : getRecentHalfHours(7); // Adjusted for mobile devices
        
        // Formats labels for X-axis as 'Jul 28, 09' (24-hour)
        function formatDateLabel(dt) {
            const month = dt.toLocaleString(navigator.language, { month: 'short' });
            const day = dt.getDate().toString().padStart(2, '0');
            const hour = dt.getHours().toString().padStart(2, '0');
            return `${month} ${day}, ${hour}`;
        }
        const dateLabels = hourObjs.map(formatDateLabel);

        // findValueForHour function (already corrected in previous turn)
        function findValueForHour(dt, key) {
            // dt: Date object, key: 'PH' or 'ORP'
            // target: 'YYYY-MM-DD HH:MM'

            // Extract parts of the Date object in local timezone
            const year = dt.getFullYear();
            const month = (dt.getMonth() + 1).toString().padStart(2, '0'); // getMonth() is 0-indexed
            const day = dt.getDate().toString().padStart(2, '0');
            const hours = dt.getHours().toString().padStart(2, '0');

            // This creates the exact format 'YYYY-MM-DD HH:MM' using local time values
            const ymdhm = `${year}-${month}-${day} ${hours}`;

            for (let i = 0; i < realtimeData.length; i++) {
                const t = realtimeData[i].time;
                // Check if realtimeData[i].time starts with our generated local time string
                // Assuming realtimeData[i].time is also in local time or can be compared this way
                if (t && t.startsWith(ymdhm)) {
                    return typeof realtimeData[i][key] === 'number' ? realtimeData[i][key] : null;
                }
            }
            return null; // Return null if no match is found
        }
        
        const phHourValues = hourObjs.map(dt => findValueForHour(dt, 'PH'));
        const orpHourValues = hourObjs.map(dt => findValueForHour(dt, 'ORP'));

        const realtimeElem = document.getElementById('realtimeChart');
        let lastLabel = ""; // Renamed from lastLabel to be more specific (lastDayLabel) for X-axis callback

        // Unified color constants
        const COLORS = {
            ph: 'rgba(255, 159, 64, 0.24)',  // Orange
            orp: 'rgba(54, 162, 235, 1)', // Blue
            n: 'rgba(75, 192, 192, 1)',   // Teal
            p: 'rgba(255, 99, 132, 1)',   // Red
            ca: 'rgba(255, 206, 86, 1)',  // Yellow
            mg: 'rgba(128, 128, 128, 0.12)', // Gray (changed from transparent for better visibility)
            kh: 'rgba(153, 102, 255, 1)', // Purple
            t: 'rgba(0, 200, 80, 1)',     // Green (used for temp, but not in current charts)
        }; 

        const skipped = (ctx, value) => ctx.p0.skip || ctx.p1.skip ? value : undefined;

        const realtimeChart = new Chart(realtimeElem.getContext('2d'), {
            type: 'line',
            data: {
                labels: dateLabels,
                datasets: [
                    {
                        label: 'PH',
                        data: phHourValues,
                        borderColor: COLORS.ph,
                        backgroundColor: COLORS.ph.replace('1)', '0.2)'), // Add transparency for fill color
                        fill: true, // Enable area fill
                        tension: 0.4,
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        yAxisID: 'yLeft',
                        spanGaps: true, // Connect null points
                        segment: {
                            borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                            borderDash: ctx => skipped(ctx, [6, 6]),
                        }
                    },
                    {
                        label: 'ORP',
                        data: orpHourValues,
                        borderColor: COLORS.orp,
                        backgroundColor: COLORS.orp.replace('1)', '0.1)'),
                        fill: false, // Do not fill area for ORP
                        tension: 0.4,
                        borderWidth: 3,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        yAxisID: 'yRight',
                        spanGaps: true, // Connect null points
                        segment: {
                            borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.1)'),
                            borderDash: ctx => skipped(ctx, [6, 6]),
                        }
                    }
                ]
            },   
            options: {
                responsive: true,
                maintainAspectRatio: false, // Allow CSS to control height
                interaction: {
                    mode: 'nearest',
                    axis: 'xy',
                    intersect: false
                },
                scales: {
                    x: {
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 12
                            },
                            autoSkip: false, // We control skipping manually
                            callback: function(value, index, ticks) {
                                // Get the full label string (e.g., "Jul 27, 04:00 AM")
                                const fullLabel = this.getLabelForValue(value);

                                const datePart = fullLabel.split(',')[0];
                                // console.log("datePart: " + datePart);
                                // Only display label if it's 12 AM (midnight) for a new day
                                if (fullLabel.includes('00')) {
                                    return datePart;
                                } 
                                return ''; // Hide other labels
                            }
                        },
                        grid: {
                            drawTicks: false,
                            drawOnChartArea: true,
                            drawBorder: true,
                            color: 'rgba(180,180,180,0.1)'
                        }
                    },
                    yLeft: {
                        type: 'linear',
                        position: 'left',
                        beginAtZero: false,
                        // Calculate suggestedMax based on actual filtered values
                        suggestedMax: phHourValues.filter(v => v !== null).length > 0 ? 
                                      1.1 * Math.max(...phHourValues.filter(v => v !== null)) : 10,
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 14
                            }
                        },
                        grid: {
                            color: 'rgba(180,180,180,0.12)'
                        }
                    },
                    yRight: {
                        type: 'linear',
                        position: 'right',
                        beginAtZero: false,
                        // Calculate suggestedMax based on actual filtered values
                        suggestedMax: orpHourValues.filter(v => v !== null).length > 0 ?
                                      1.002 * Math.max(...orpHourValues.filter(v => v !== null)) : 500,
                        ticks: {
                            font: {
                                family: 'Oswald',
                                size: 14
                            },
                            callback: function(value) {
                                return value.toFixed(0); // Show ORP as whole numbers
                            }
                        },
                        grid: {
                            drawOnChartArea: false // Hide horizontal grid lines for right Y-axis
                        }
                    }
                },
                plugins: {
                    title: {
                        display: false,
                        text: 'Real Time Tracking',
                        font: { family: 'Oswald', size: 14 },
                        align: 'top'
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'nearest',
                        intersect: true,
                        bodyFont: { family: 'Oswald', size: 14 },
                        callbacks: {
                            title: function(context) {
                                // context[0] is the hovered item
                                const idx = context[0].dataIndex;
                                const dt = hourObjs[idx]; // Get the original Date object
                                
                                if (dt instanceof Date) {
                                    // Use toLocaleString for a user-friendly timestamp in their locale
                                    return dt.toLocaleString(navigator.language, { 
                                        month: 'short', 
                                        day: 'numeric', 
                                        hour: '2-digit', 
                                        minute: '2-digit', 
                                        hour12: true 
                                    });
                                }
                                return '';
                            },
                            label: function(context) {
                                const key = context.dataset.label;
                                const value = context.parsed.y;
                                let formattedValue = 'N/A';

                                if (value !== null) {
                                    switch (key) {
                                        case 'ORP':
                                            formattedValue = value.toFixed(0);
                                            break;
                                        case 'PH':
                                            formattedValue = value.toFixed(1);
                                            break;
                                        default:
                                            formattedValue = value.toFixed(0);
                                    }
                                }

                                return `${key}: ${formattedValue}`;
                            }
                        }
                    }
                }
            }
        });

        const rawData = {{ chart_data|tojson }} || [];
        const chartElem = document.getElementById('staticChartLeft');
        const chartRightElem = document.getElementById('staticChartRight');
        
        const ctx = chartElem.getContext('2d');
        const ctxRight = chartRightElem.getContext('2d');

        const colorPalette = [
            COLORS.n, // Nitrate (Teal)
            COLORS.p, // Phosphate (Red)
            COLORS.ca, // Calcium (Yellow)
            COLORS.mg, // Magnesium (Gray)
            COLORS.kh, // Alkalinity (Purple)
        ];

        // Helper to get week start from date string (assumes format like "Mon DD" or 'YYYY-MM-DD')
        // We'll try to parse it more robustly
        function getWeekStart(dateStr) {
            // First, try to parse as ISO-like, then get the date
            let d;
            if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) { // YYYY-MM-DD format
                d = new Date(dateStr + 'T00:00:00'); // Ensure it's treated as a local date
            } else { // Assume it's "Mon DD"
                d = new Date(dateStr + ', ' + new Date().getFullYear()); // Add current year for parsing
            }

            // Find Monday (week start)
            const dayOfWeek = d.getDay(); // 0 for Sunday, 1 for Monday, ..., 6 for Saturday
            const diffToMonday = d.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
            const monday = new Date(d);
            monday.setDate(diffToMonday);

            // Find Sunday (week end) for label: Monday + 6 days
            const sunday = new Date(monday);
            sunday.setDate(monday.getDate() + 6);

            // Format to "Mon DD" for labels (will show Sunday date)
            return sunday.toLocaleDateString(navigator.language, { month: 'short', day: 'numeric' });
        }

        // Group all entries by week
        const weekMap = {};
        rawData.forEach(d => {
            const week = getWeekStart(d.date);
            if (!weekMap[week]) weekMap[week] = {};
            ['N','P','CA','MG','KH'].forEach(key => {
                if (typeof d[key] === 'number') { // Only push if it's a number
                    if (!weekMap[week][key]) weekMap[week][key] = [];
                    weekMap[week][key].push(d[key]);
                }
            });
        });

        // Aggregate values for each week (average)
        function avg(arr) {
            if (!arr || arr.length === 0) return null;
            return parseFloat((arr.reduce((a,b) => a+b,0) / arr.length).toFixed(2));
        }

        const labels = Object.keys(weekMap).sort((a,b) => {
            // Custom sort for "Mon DD" format
            const dateA = new Date(a + ', ' + new Date().getFullYear());
            const dateB = new Date(b + ', ' + new Date().getFullYear());
            return dateA - dateB;
        });

        const elementKeysLeft = ['N', 'P']; // Left Chart Elements
        const elementDataLeft = {};  
        elementKeysLeft.forEach(key => {
            elementDataLeft[key] = labels.map(week => {
                const arr = weekMap[week][key];
                return arr ? avg(arr) : null;
            });
        });

        const elementKeysRight = ['CA', 'MG', 'KH']; // Right Chart Elements
        const elementDataRight = {};
        elementKeysRight.forEach(key => {
            elementDataRight[key] = labels.map(week => {
                const arr = weekMap[week][key];
                return arr ? avg(arr) : null;
            });
        });

        // Assign yAxisID: No3 on left, Po4 on right for the left chart
        function getAxisLeftChart(key) {
            return key === 'N' ? 'yLeft' : 'yRight';
        }
        const datasetsLeft = elementKeysLeft.map((key, idx) => ({
            label: key === 'N' ? 'Nitrate' : 'Phosphate', // Assuming only N and P here
            data: elementDataLeft[key],
            borderColor: COLORS[key.toLowerCase()], // Use predefined colors
            backgroundColor: COLORS[key.toLowerCase()].replace('1)', '0.2)'),
            fill: true,
            tension: 0.4,
            borderWidth: 2,
            pointRadius: 0,
            pointHoverRadius: 6,
            yAxisID: getAxisLeftChart(key),
            spanGaps: true,
            segment: {
                borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                borderDash: ctx => skipped(ctx, [6, 6]),
            }
        }));

        // Right chart: CA and MG as stacked bars, KH as line
        function getAxisRightChart(key) {
            // CA and MG might share one axis (right), KH on another (left)
            return key === 'KH' ? 'yLeft' : 'yRight';
        }
        const datasetsRight = elementKeysRight.map((key, idx) => {
            const baseColor = colorPalette[(idx + 2) % colorPalette.length]; // Re-use color palette or define more
            if (key === 'MG' || key === 'CA') {
                return {
                    label: key === 'MG' ? 'Magnesium' : 'Calcium',
                    data: elementDataRight[key],
                    backgroundColor: COLORS[key.toLowerCase()],
                    type: 'bar',
                    stack: 'elementsStack', // All bars that should stack use the same stack ID
                    yAxisID: getAxisRightChart(key),
                    order: 1,
                    segment: {
                        borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                        borderDash: ctx => skipped(ctx, [6, 6]),
                    }
                };
            } else { // KH
                return {
                    label: 'Alk', // Label for KH
                    data: elementDataRight[key],
                    borderColor: COLORS.kh,
                    backgroundColor: COLORS.kh.replace('1)', '0.2)'),
                    fill: false,
                    type: 'line',
                    tension: 0.4,
                    borderWidth: 2,
                    pointRadius: 0,
                    pointHoverRadius: 6,
                    yAxisID: getAxisRightChart(key),
                    spanGaps: true,
                    order: 0,
                    segment: {
                        borderColor: ctx => skipped(ctx, 'rgb(0,0,0,0.2)'),
                        borderDash: ctx => skipped(ctx, [6, 6]),
                    }
                };
            }
        });

        const myChartLeft = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasetsLeft
            },
            options: {
                responsive: true,
                maintainAspectRatio: false, // Allow CSS to control height
                scales: {
                    x: {
                        ticks: {
                            font: { family: 'Oswald', size: 13 },
                            // Improve X-axis label display for weeks
                            callback: function(value, index, ticks) {
                                // Only display every X labels if too many, or always if few
                                return this.getLabelForValue(value);
                            }
                        },
                        grid: {
                            drawTicks: false,
                            drawOnChartArea: true,
                            drawBorder: true,
                            color: 'rgba(180,180,180,0.12)'
                        }
                    },
                    yLeft: {
                        type: 'linear',
                        position: 'left',
                        beginAtZero: true,
                        suggestedMax: elementDataLeft['N'].filter(v => v !== null).length > 0 ? 
                                      1.3 * Math.max(...elementDataLeft['N'].filter(v => v !== null)) : 10,
                        ticks: { font: { family: 'Oswald', size: 14 } },
                        grid: { color: 'rgba(180,180,180,0.12)' }
                    },
                    yRight: {
                        type: 'linear',
                        position: 'right',
                        beginAtZero: true,
                        suggestedMax: elementDataLeft['P'].filter(v => v !== null).length > 0 ? 
                                      1.1 * Math.max(...elementDataLeft['P'].filter(v => v !== null)) : 0.2,
                        ticks: { font: { family: 'Oswald', size: 14 } },
                        grid: { drawOnChartArea: false }
                    }
                },
                interaction: { mode: 'nearest', axis: 'xy', intersect: false },
                plugins: {
                    title: { display: false, text: 'Nutrition', font: { family: 'Oswald', size: 14 }, align: 'start' },
                    legend: { display: true, position: 'top'},
                    tooltip: {
                        enabled: true, mode: 'nearest', intersect: true, bodyFont: { family: 'Oswald', size: 14 },
                        callbacks: {
                            label: function(context) {
                                const key = context.dataset.label === 'Nitrate' ? 'N' : 'P';
                                const value = context.parsed.y;
                                let formattedValue = 'N/A';

                                if (value !== null) {
                                    switch (key) {
                                        case 'Nitrate': // N
                                            formattedValue = value.toFixed(1);
                                            break;
                                        case 'Phosphate': // P
                                            formattedValue = value.toFixed(2);
                                            break;
                                        default:
                                            formattedValue = value.toString();
                                    }
                                }

                                return `${context.dataset.label}: ${formattedValue}`;
                            }
                        }
                    }
                }
            }
        });

        // Right chart
        const myChartRight = new Chart(ctxRight, {
            type: 'bar', // Default type for this chart
            data: {
                labels: labels,
                datasets: datasetsRight
            },
            options: {
                responsive: true,
                maintainAspectRatio: false, // Allow CSS to control height
                scales: {
                    x: {
                        stacked: true, // Enable stacking for bars on x-axis
                        ticks: { font: { family: 'Oswald', size: 13 } },
                        grid: { drawTicks: false, drawOnChartArea: true, drawBorder: true, color: 'rgba(180,180,180,0.12)' }
                    },
                    yLeft: { // For KH (Alk)
                        type: 'linear',
                        position: 'left',
                        beginAtZero: false, // Alk might not start at zero
                        suggestedMax: elementDataRight['KH'].filter(v => v !== null).length > 0 ? 
                                      1.05 * Math.max(...elementDataRight['KH'].filter(v => v !== null)) : 10,
                        ticks: { font: { family: 'Oswald', size: 14 } },
                        grid: { color: 'rgba(180,180,180,0.12)' }
                    },
                    yRight: { // For CA, MG (stacked bars)
                        type: 'linear',
                        position: 'right',
                        beginAtZero: true,
                        stacked: false, // y-axis itself is not stacked, individual datasets are
                        suggestedMax: Math.max(
                            elementDataRight['CA'].filter(v => v !== null).length > 0 ? Math.max(...elementDataRight['CA'].filter(v => v !== null)) : 0,
                            elementDataRight['MG'].filter(v => v !== null).length > 0 ? Math.max(...elementDataRight['MG'].filter(v => v !== null)) : 0
                        ) * 1.1, // Adjusted max for stacked bars
                        ticks: { font: { family: 'Oswald', size: 14 } },
                        grid: { drawOnChartArea: false }
                    }
                },
                interaction: { mode: 'nearest', axis: 'xy', intersect: false },
                plugins: {
                    title: { display: false, text: 'Huge Elements', font: { family: 'Oswald', size: 14 }, align: 'top' },
                    legend: { display: true, position: 'top' },
                    tooltip: {
                        enabled: true, mode: 'nearest', intersect: true, bodyFont: { family: 'Oswald', size: 14 },
                        filter: function(tooltipItem, data) {
                            // Only show tooltip for the line dataset (assuming it's datasetIndex 0)
                            return tooltipItem.datasetIndex === 2; 
                        },
                        callbacks: {
                            label: function(context) {
                                // Map label to original key
                                const labelMap = { 'Calcium': 'CA', 'Magnesium': 'MG', 'Alk': 'KH' };
                                const key = labelMap[context.dataset.label] || context.dataset.label;
                                const value = context.parsed.y;
                                let formattedValue = 'N/A';

                                if (value !== null) {
                                    switch (key) {
                                        case 'Calcium': // CA
                                            formattedValue = value.toFixed(0);
                                            break;
                                        case 'Magnesium': // MG
                                            formattedValue = value.toFixed(0);
                                            break;
                                        case 'Alk': // KH
                                            formattedValue = value.toFixed(1);
                                            break;
                                        default:
                                            formattedValue = value.toString();
                                    }
                                }

                                return `${context.dataset.label}: ${formattedValue}`;
                            }
                        }
                    }
                }
            }
        });

        // Dynamically update element values for the elements list
        const elements = {
            nElement: 'N',
            pElement: 'P',
            caElement: 'CA',
            mgElement: 'MG',
            khElement: 'KH',
            orpElement: 'ORP',
            phElement: 'PH',
            tempElement: 'T'
        };

        // Get latest week label
        const latestWeek = labels.length > 0 ? labels[labels.length - 1] : null;
        // Helper to get latest value from weekMap for a key
        function getLatestWeekValue(key) {
            if (!latestWeek || !weekMap[latestWeek] || !weekMap[latestWeek][key]) return null;
            const arr = weekMap[latestWeek][key];
            if (!arr || arr.length === 0) return null;
            // Use the last value in the array for the week
            return arr[arr.length - 1];
        }
        // Helper to get latest value from realtimeData for a key
        function getLatestRealtimeValue(key) {
            for (let i = 0; i < realtimeData.length; i++) {
                const v = realtimeData[i][key];
                if (v !== undefined && v !== null) return v;
            }
            return null;
        }

        // Update values in the elements list
        Object.keys(elements).forEach(id => {
            const element = document.getElementById(id);
            const key = elements[id];
            let value = '-';

            if (["N","P","CA","MG","KH"].includes(key)) {
                const v = getLatestWeekValue(key);
                value = v !== null && v !== undefined ? v : '-';
            } else {
                const v = getLatestRealtimeValue(key);
                value = v !== null && v !== undefined ? v : '-';
                // Only show ORP/PH/Temperature if there is a value
                element.style.display = (value !== '-') ? 'list-item' : 'none';
            }

            element.querySelector('span').textContent += value;
        });

        // --- Update Elements List with Data ---
        // Define max values for percentage calculation
        const MAX_VALUES = {
            N: 2,    // Nitrate max for bar (e.g., 20 ppm)
            P: 0.03,   // Phosphate max for bar (e.g., 0.2 ppm)
            CA: 400,  // Calcium max for bar (e.g., 500 ppm)
            MG: 1320, // Magnesium max for bar (e.g., 1500 ppm)
            KH: 8,   // Alkalinity max for bar (e.g., 12 dKH)
            ORP: 380, // ORP max for bar (e.g., 450 mV)
            PH: 8,  // PH max for bar (e.g., 8.5)
            T: 24  // Temperature max for bar (e.g., 82 F)
        };

        function updateElementsList() {
            // Get the latest data for PH, ORP, Temp from realtimeData
            const latestRealtimeData = realtimeData.length > 0 ? realtimeData[0] : null;

            // Get the latest averaged data for N, P, CA, MG, KH from chart_data (weekly average)
            // This is a simplification; ideally, you'd have a separate "latest" data source for these.
            // For now, we'll use the last week's average from chart_data.
            const latestWeeklyData = labels.length > 0 ? rawData.find(d => getWeekStart(d.date) === labels[labels.length - 1]) : null;

            const elementsToUpdate = { 
                N: { id: 'nElement', name: 'Nitrate (N):', value: latestWeeklyData ? latestWeeklyData.N : null, decimals: 1 },
                P: { id: 'pElement', value: latestWeeklyData ? latestWeeklyData.P : null, decimals: 2 },
                CA: { id: 'caElement', value: latestWeeklyData ? latestWeeklyData.CA : null, decimals: 0 },
                MG: { id: 'mgElement', value: latestWeeklyData ? latestWeeklyData.MG : null, decimals: 0 },
                KH: { id: 'khElement', value: latestWeeklyData ? latestWeeklyData.KH : null, decimals: 1 },
                ORP: { id: 'orpElement', value: latestRealtimeData ? latestRealtimeData.ORP : null, decimals: 0 },
                PH: { id: 'phElement', value: latestRealtimeData ? latestRealtimeData.PH : null, decimals: 1 },
                T: { id: 'tempElement', value: latestRealtimeData ? latestRealtimeData.T : null, decimals: 1 } // Use 'T' for temperature
            };

            const BAR_FULL_AT = 0.7; // 70% of max is 100% for the bar
            for (const key in elementsToUpdate) {
                const elementInfo = elementsToUpdate[key];
                const listItem = document.getElementById(elementInfo.id);
                if (listItem) {
                    const percentageSpan = listItem.querySelector('.element-percentage');
                    const progressBarFill = listItem.querySelector('.progress-bar-fill');
                    const value = elementInfo.value;
                    const maxValue = MAX_VALUES[key];

                    if (value !== null && typeof value === 'number') {
                        let per_show = (value / (maxValue)) * 100;
                        let percentage = per_show * BAR_FULL_AT;
                        percentageSpan.textContent = `${per_show.toFixed(0)}%`;
                        progressBarFill.style.width = `${percentage}%`;
                        progressBarFill.style.backgroundColor = COLORS[key.toLowerCase()];
                        // Set color by range
                        if (per_show < 50) {
                            percentageSpan.style.color = '#a259e6'; // purple
                        } else if (per_show < 80) {
                            percentageSpan.style.color = '#3b82f6'; // blue
                        } else if (per_show < 120) {
                            percentageSpan.style.color = '#22c55e'; // green
                        } else if (per_show < 150) {
                            percentageSpan.style.color = '#facc15'; // yellow
                        } else {
                            percentageSpan.style.color = '#ef4444'; // red
                        }
                    } else {
                        percentageSpan.textContent = 'N/A';
                        percentageSpan.style.color = '#333';
                        progressBarFill.style.width = '0%';
                        progressBarFill.style.backgroundColor = '#e0e0e0';
                    }
                }
            }
        }

        // Call update function after charts are initialized or data is loaded
        updateElementsList();
    </script>
</body>
</html>