<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <!-- Cropper.js CSS -->
    <link  href="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.css" rel="stylesheet"/>
    <style>
    /* 裁剪弹窗样式 */
    #cropper-modal {
        display: none;
        position: fixed;
        z-index: 9999;
        left: 0; top: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5);
        align-items: center;
        justify-content: center;
    }
    #cropper-modal.active {
        display: flex;
    }
    #cropper-modal-content {
        background: #fff;
        border-radius: 12px;
        padding: 24px 18px 18px 18px;
        min-width: 320px;
        max-width: 95vw;
        box-shadow: 0 8px 32px rgba(0,0,0,0.18);
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    #cropper-image {
        max-width: 320px;
        max-height: 320px;
        display: block;
        margin-bottom: 18px;
        border-radius: 8px;
    }
    </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>故事线</title>
    <!-- Include Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 媒体查询：当屏幕宽度小于640px时应用缩放 */
        :root {
            --mobile-scale: 0.4;
        }
        @media (max-width: 640px) {
            body {
                /* 使用 CSS 变量控制缩放比例 */
                transform: scale(var(--mobile-scale));
                transform-origin: top left;
                width: calc(250vw);
                height: 20vh;
                overflow-x: auto;
            }
        }

        .action-btn, .header-action-btn, .footer-action-btn, #add-node-button {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        .timeline-item:hover .action-btn,
        .action-btn:hover {
            opacity: 1;
            pointer-events: auto;
        }
        /* Header action button visibility on hover */
        .container:hover > .header-action-btn,
        .header-action-btn:hover {
            opacity: 1;
            pointer-events: auto;
        }
        /* Footer action button visibility on hover */
        footer .container:hover .footer-action-btn,
        .footer-action-btn:hover {
            opacity: 1;
            pointer-events: auto;
        }
        /* Add node button visibility on hover */
        .flex.justify-center:hover #add-node-button,
        #add-node-button:hover {
            opacity: 1;
            pointer-events: auto;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #fff;
        }
        /* Header font size smaller */
        #main-title {
            font-size: 3rem !important;
            color: #111 !important;
        }
        #subtitle {
            font-size: 1rem !important;
            color: #222 !important;
        }
        #footer-text {
            color: #222 !important;
        }
        /* Timeline styles */
        .timeline {
            position: relative;
            overflow: visible !important;
        }
        .timeline-item {
            position: relative;
            padding-top: 0;
            padding-bottom: 0;
            padding-left: 0;
            padding-right: 0;
            width: 50%;
            z-index: 2; /* Ensure timeline items are above the connector lines */
        }
        .timeline-item.is-right {
            margin-left: 50%;
            padding-left: 5.5rem;
            text-align: left;
            transform: translateX(10%);
        }
        .timeline-item.is-left {
            margin-right: 50%;
            padding-right: 5.5rem;
            text-align: right;
            transform: translateX(-10%);
        }
        .timeline-dot {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border: 2px solid;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .timeline-item.is-left .timeline-dot {
            right: 20px;
            transform: translateY(-50%) translateX(30%);
        }
        .timeline-item.is-right .timeline-dot {
            left: 20px;
            transform: translateY(-50%) translateX(-30%);
        }
        .timeline-divider {
            height: 2px;
            width: 100%;
            margin: 0.5rem 0;
        }
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 50;
            background: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        .modal.active {
            display: flex;
        }
        /* SVG connector line styles */
        .timeline-connector {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            min-width: 100%;
            height: 100%;
            min-height: 100%;
            pointer-events: none;
            overflow: visible;
            z-index: 1; /* Ensure connectors are behind the timeline items */
        }
        /* Custom confirmation modal styles */
        #confirm-modal {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 50;
            background: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        #confirm-modal.active {
            display: flex;
        }
    </style>
</head>
    <!-- Cropper.js -->
    <script src="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.js"></script>
<body class="bg-white text-black">

    <!-- 裁剪图片弹窗 -->
    <div id="cropper-modal">
      <div id="cropper-modal-content">
        <img id="cropper-image" src="" alt="裁剪图片" />
        <div class="flex gap-4 mt-2">
          <button id="cropper-cancel" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">取消</button>
          <button id="cropper-confirm" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">确定</button>
        </div>
      </div>
    </div>

    <!-- Header Section -->
    <header class="bg-white text-black p-6 md:p-8">
        <div class="container mx-auto flex flex-row items-center justify-between w-full">
            <div id="header-content" class="text-center flex-1">
                <h1 id="main-title" class="text-5xl md:text-6xl lg:text-7xl font-extrabold tracking-tight mb-2">THE LOVE STORY</h1>
                <p id="subtitle" class="text-lg md:text-xl text-gray-300">A Journey Through Time for you or what you love</p>
            </div>
            <button onclick="openHeaderModal()" class="header-action-btn ml-4 px-6 py-2 bg-blue-600 text-white rounded-full hover:bg-blue-700 transition-colors shadow-md self-start">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.389-8.379-2.83-2.828z" />
                </svg>
            </button>
        </div>
    </header>

    <!-- Main Content Section -->
    <main class="container mx-auto px-4 py-8">
        <div class="flex justify-center">
            <button id="add-node-button" onclick="openAddModal()" class="header-action-btn flex items-center justify-center w-14 h-14 bg-green-600 text-white rounded-full hover:bg-green-700 transition-colors shadow-lg text-3xl">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                </svg>
            </button>
        </div>
        <div id="timeline-container" class="timeline relative max-w-4xl mx-auto">
            <!-- SVG container for drawing the connector lines -->
            <svg id="timeline-connector-svg" class="timeline-connector"></svg>
            <!-- Timeline items will be rendered here by JavaScript -->
        </div>
    </main>

    <!-- Footer Section -->
    <footer class="bg-white text-black p-4 text-center mt-8">
        <div class="container mx-auto flex items-center justify-center gap-2">
            <p id="footer-text" class="text-sm mb-0">© 2024 The Love Company. All rights reserved.</p>
            <button onclick="openFooterModal()" class="footer-action-btn px-4 py-1 text-xs bg-blue-600 text-white rounded-full hover:bg-blue-700 transition-colors shadow-md ml-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.389-8.379-2.83-2.828z" />
                </svg>
            </button>
        </div>
    </footer>

    <!-- Modals for editing -->

    <!-- Modal for adding/editing a timeline node -->
    <div id="node-modal" class="modal fixed inset-0 bg-black bg-opacity-50 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md">
            <h2 id="modal-title" class="text-2xl font-bold mb-4">增加新节点</h2>
            <form id="node-form" class="space-y-4">
                <div>
                    <label for="title" class="block text-sm font-medium text-gray-700">标题 (如: Initial Consult)</label>
                    <input type="text" id="title" name="title" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2" required>
                </div>
                <div>
                    <label for="content" class="block text-sm font-medium text-gray-700">内容 (不超过200字)</label>
                    <textarea id="content" name="content" rows="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2" maxlength="200" required></textarea>
                </div>
                <div>
                    <label for="color" class="block text-sm font-medium text-gray-700">颜色</label>
                    <input type="color" id="color" name="color" value="#10b981" class="mt-1 block w-full h-10 rounded-md border-gray-300 shadow-sm p-1">
                </div>
                <div>
                    <label for="imageUpload" class="block text-sm font-medium text-gray-700">图片 (100x100 裁剪)</label>
                    <input type="file" id="imageUpload" name="imageUpload" accept="image/*" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                </div>
                <div class="flex justify-end space-x-2">
                    <button type="button" onclick="closeModal('node-modal')" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">取消</button>
                    <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">保存</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal for editing header -->
    <div id="header-modal" class="modal fixed inset-0 bg-black bg-opacity-50 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md">
            <h2 class="text-2xl font-bold mb-4">修改头部</h2>
            <form id="header-form" class="space-y-4">
                <div>
                    <label for="modal-main-title" class="block text-sm font-medium text-gray-700">主标题</label>
                    <input type="text" id="modal-main-title" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2">
                </div>
                <div>
                    <label for="modal-subtitle" class="block text-sm font-medium text-gray-700">副标题</label>
                    <input type="text" id="modal-subtitle" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2">
                </div>
                <div class="flex justify-end space-x-2">
                    <button type="button" onclick="closeModal('header-modal')" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">取消</button>
                    <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">保存</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal for editing footer -->
    <div id="footer-modal" class="modal fixed inset-0 bg-black bg-opacity-50 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md">
            <h2 class="text-2xl font-bold mb-4">修改页脚</h2>
            <form id="footer-form" class="space-y-4">
                <div>
                    <label for="modal-footer-text" class="block text-sm font-medium text-gray-700">页脚文本</label>
                    <input type="text" id="modal-footer-text" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2">
                </div>
                <div class="flex justify-end space-x-2">
                    <button type="button" onclick="closeModal('footer-modal')" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">取消</button>
                    <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">保存</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Custom Confirmation Modal -->
    <div id="confirm-modal" class="modal">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm">
            <h2 id="confirm-title" class="text-xl font-bold mb-4">确认</h2>
            <p id="confirm-message" class="mb-6 text-gray-700">你确定要执行此操作吗？</p>
            <div class="flex justify-end space-x-2">
                <button type="button" id="confirm-cancel" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">取消</button>
                <button type="button" id="confirm-ok" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">确定</button>
            </div>
        </div>
    </div>

    <script>
        // 全局移动端缩放参数，便于统一维护
        const MOBILE_SCALE = 0.4;
        // Custom modal replacement for alert() and confirm()
        function showCustomConfirm(message, title = '确认操作') {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirm-modal');
                const titleEl = document.getElementById('confirm-title');
                const messageEl = document.getElementById('confirm-message');
                const okBtn = document.getElementById('confirm-ok');
                const cancelBtn = document.getElementById('confirm-cancel');

                titleEl.textContent = title;
                messageEl.textContent = message;
                modal.classList.add('active');

                const onOk = () => {
                    modal.classList.remove('active');
                    okBtn.removeEventListener('click', onOk);
                    cancelBtn.removeEventListener('click', onCancel);
                    resolve(true);
                };
                const onCancel = () => {
                    modal.classList.remove('active');
                    okBtn.removeEventListener('click', onOk);
                    cancelBtn.removeEventListener('click', onCancel);
                    resolve(false);
                };

                okBtn.addEventListener('click', onOk);
                cancelBtn.addEventListener('click', onCancel);
            });
        }
        
        // Global variable to store node data
        let nodesData = [];
        
        // Define an array of 7 darker colors
         const macaronColors = [
            "#B3E0F2", // Powder Blue
            "#F9D3E6", // Pale Pink
            "#C4E8D0", // Mint Green
            "#F9EBAD", // Creamy Yellow
            "#DED0F2", // Lavender
            "#F0B3B3", // Coral Pink
            "#B3D9FF"  // Sky Blue
        ];

        const API_URL = 'http://192.168.0.28:5003/api/timeline';
        let editingNodeId = null;

        // Fetch and render timeline nodes
        async function fetchAndRenderNodes() {
            try {
                const response = await fetch(API_URL);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                nodesData = await response.json(); // Store data in a global variable
                renderTimeline(nodesData);
                // Call renderConnectors after a short delay to allow for DOM rendering
                setTimeout(() => {
                    renderConnectors(nodesData);
                }, 100);
            } catch (error) {
                console.error("Failed to fetch timeline nodes:", error);
                renderTimeline([]); // Do not display any nodes
                renderConnectors([]); // Do not display any connector lines
            }
        }
        
        // Render the timeline UI
        // 大图预览弹窗DOM
        function ensureImagePreviewModal() {
            if (document.getElementById('image-preview-modal')) return;
            const modal = document.createElement('div');
            modal.id = 'image-preview-modal';
            modal.style.display = 'none';
            modal.style.position = 'fixed';
            modal.style.zIndex = 99999;
            modal.style.left = 0;
            modal.style.top = 0;
            // 动态适配 mobile 缩放
            let modalWidth = '100vw', modalHeight = '100vh', imgMaxWidth = '60vw', imgMaxHeight = '640px';
            if (window.innerWidth < 640) {
                modalWidth = (100 / MOBILE_SCALE) + 'vw';
                imgMaxWidth = (60 / MOBILE_SCALE) + 'vw';
                imgMaxHeight = (640 / MOBILE_SCALE) + 'px';
            }
            modal.style.width = modalWidth;
            modal.style.height = modalHeight;
            modal.style.background = 'rgba(0,0,0,0.25)';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.pointerEvents = 'none';
            modal.innerHTML = `<div id="image-preview-content" style="display:flex;align-items:center;justify-content:center;width:${modalWidth};height:${modalHeight};"><img id="image-preview-img" style="max-height:${imgMaxHeight};max-width:${imgMaxWidth};border:4px solid #fff;border-radius:10px;box-shadow:0 8px 32px rgba(0,0,0,0.18);background:#fff;object-fit:contain;" /></div>`;
            document.body.appendChild(modal);
        }

        function showImagePreview(src) {
            ensureImagePreviewModal();
            const modalEl = document.getElementById('image-preview-modal');
            const img = document.getElementById('image-preview-img');
            img.src = src;
            modalEl.style.display = 'flex';
            modalEl.style.pointerEvents = 'auto';
        }
        function hideImagePreview() {
            const modalEl = document.getElementById('image-preview-modal');
            if (modalEl) {
                modalEl.style.display = 'none';
                modalEl.style.pointerEvents = 'none';
            }
        }

        function renderTimeline(nodes) {
            const container = document.getElementById('timeline-container');
            const svgElement = document.getElementById('timeline-connector-svg');
            const centerLine = document.querySelector('.timeline-center-line');
            container.innerHTML = '';
            if (centerLine) container.appendChild(centerLine);
            if (svgElement) container.appendChild(svgElement);

            nodes.forEach((node, index) => {
                const isRight = index % 2 === 1;
                const alignmentClass = 'timeline-item ' + (isRight ? 'is-right' : 'is-left');
                const actionBtnDiv = isRight
                  ? `<div class="absolute top-2 right-2 flex space-x-2">
                        <button onclick="openEditModal('${node.id}')" class="action-btn rounded-full bg-blue-500 hover:bg-blue-600 text-white shadow-md p-2 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-300" title="编辑">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.389-8.379-2.83-2.828z" />
                            </svg>
                        </button>
                        <button onclick="deleteNode('${node.id}')" class="action-btn rounded-full bg-red-500 hover:bg-red-600 text-white shadow-md p-2 transition-colors focus:outline-none focus:ring-2 focus:ring-red-300" title="删除">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>`
                  : `<div class="absolute top-2 left-2 flex space-x-2">
                        <button onclick="openEditModal('${node.id}')" class="action-btn rounded-full bg-blue-500 hover:bg-blue-600 text-white shadow-md p-2 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-300" title="编辑">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.389-8.379-2.83-2.828z" />
                            </svg>
                        </button>
                        <button onclick="deleteNode('${node.id}')" class="action-btn rounded-full bg-red-500 hover:bg-red-600 text-white shadow-md p-2 transition-colors focus:outline-none focus:ring-2 focus:ring-red-300" title="删除">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>`;

                // 优先显示 avatar_image，其次 original_image，再次 image 字段
                let imgSrc = node.avatar_image || node.original_image || node.image || 'https://placehold.co/100x100';

                const html = `
                    <div class="${alignmentClass} flex items-center" id="node-${node.id}">
                        <div class="relative w-full">
                            <div class="bg-white rounded-lg p-6 shadow-lg">
                                <div class="mb-2">
                                    <span class="font-semibold text-lg text-gray-800">${node.title}</span>
                                </div>
                                <div class="timeline-divider" style="background-color: ${node.color};"></div>
                                <p class="mt-2 text-gray-600 text-left">${node.content}</p>
                                ${actionBtnDiv}
                            </div>
                        </div>
                        <div class="timeline-dot" style="border-color: ${node.color};" id="dot-${node.id}">
                            <img src="${imgSrc}" alt="Node Icon" style="width:114px;height:114px;object-fit:cover;border-radius:9999px;cursor:pointer;" 
                                data-preview-src="${node.original_image || imgSrc}"
                            >
                        </div>
                    </div>
                `;
                container.innerHTML += html;
            });
            // 绑定全局关闭事件
            ensureImagePreviewModal();
            const modalEl = document.getElementById('image-preview-modal');
            if (modalEl) {
                modalEl.onmouseenter = null;
                modalEl.onmouseleave = hideImagePreview;
                modalEl.onclick = hideImagePreview;
            }
            // 挂载全局方法
            window.showImagePreview = showImagePreview;
            window.hideImagePreview = hideImagePreview;

            // 只在按下时显示大图，松开或移开时消失
            document.querySelectorAll('.timeline-dot img').forEach(img => {
                img.addEventListener('mousedown', e => {
                    showImagePreview(img.getAttribute('data-preview-src'));
                });
            });
        // 保证函数体正常闭合，无多余括号
            // 绑定全局关闭事件
            ensureImagePreviewModal();
            // 挂载全局方法
            window.showImagePreview = showImagePreview;
            window.hideImagePreview = hideImagePreview;
        }
        
        // Renders the timeline connector lines
        function renderConnectors(nodes) {
            const svg = document.getElementById('timeline-connector-svg');
            if (!svg) return;
            // Clear existing lines
            svg.innerHTML = '';
            if (nodes.length <= 1) return;
            // Always get up-to-date bounding rect (after scaling)
            const rect = svg.parentElement.getBoundingClientRect();
            // 保持 desktop 和 mobile 坐标系一致，全部用缩放后的坐标
            svg.setAttribute('width', rect.width);
            svg.setAttribute('height', rect.height);
            let dotRadius = 60;
            const gap = 15;
            for (let i = 0; i < nodes.length - 1; i++) {
                const currentNodeId = nodes[i].id;
                const nextNodeId = nodes[i+1].id;
                const currentDot = document.getElementById(`dot-${currentNodeId}`);
                const nextDot = document.getElementById(`dot-${nextNodeId}`);
                if (currentDot && nextDot) {
                    let currentRect = currentDot.getBoundingClientRect();
                    let nextRect = nextDot.getBoundingClientRect();
                    let rectLeft = rect.left;
                    let rectTop = rect.top;
                    let scale = 1;
                    if (window.innerWidth < 640) {
                        scale = MOBILE_SCALE;
                        rectLeft = rect.left / scale;
                        rectTop = rect.top / scale;
                        currentRect = {
                            left: (currentRect.left + window.scrollX) / scale,
                            top: (currentRect.top + window.scrollY) / scale,
                            width: currentRect.width / scale,
                            height: currentRect.height / scale
                        };
                        nextRect = {
                            left: (nextRect.left + window.scrollX) / scale,
                            top: (nextRect.top + window.scrollY) / scale,
                            width: nextRect.width / scale,
                            height: nextRect.height / scale
                        };
                    }
                    const currentCenterX = currentRect.left + currentRect.width / 2 - rectLeft;
                    const currentCenterY = currentRect.top + currentRect.height / 2 - rectTop;
                    const nextCenterX = nextRect.left + nextRect.width / 2 - rectLeft;
                    const nextCenterY = nextRect.top + nextRect.height / 2 - rectTop;
                    // Calculate the distance and angle between the two centers
                    const dx = nextCenterX - currentCenterX;
                    const dy = nextCenterY - currentCenterY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const lineColor = nodes[i+1].color;
                    console.log(`Drawing line from ${currentNodeId} to ${nextNodeId} with color ${lineColor}`);
                    console.log(`Current distance: (${distance}), dotRadius:(${dotRadius}),  gap: (${gap})`);

                    if (distance > 0) {
                        const unitX = dx / distance;
                        const unitY = dy / distance;
                        const startX = currentCenterX + unitX * (dotRadius + gap);
                        const startY = currentCenterY + unitY * (dotRadius + gap);
                        const endX = nextCenterX - unitX * (dotRadius + gap);
                        const endY = nextCenterY - unitY * (dotRadius + gap);
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', startX);
                        line.setAttribute('y1', startY);
                        line.setAttribute('x2', endX);
                        line.setAttribute('y2', endY);
                        line.setAttribute('stroke', lineColor);
                        line.setAttribute('stroke-width', '4');
                        line.setAttribute('stroke-linecap', 'round');
                        line.setAttribute('stroke-dasharray', '4,16');
                        svg.appendChild(line);
                    }
                }
            }
        }

        // --- Mobile/resize fix: use ResizeObserver and orientationchange to redraw connectors ---
        function setupConnectorObservers() {
            const container = document.getElementById('timeline-container');
            if (!container) return;
            // Use ResizeObserver for container size changes (including mobile scaling)
            if (window.ResizeObserver) {
                const ro = new ResizeObserver(() => {
                    renderConnectors(nodesData);
                });
                ro.observe(container);
            }
            // Redraw on orientation change
            window.addEventListener('orientationchange', () => {
                setTimeout(() => renderConnectors(nodesData), 300);
            });
        }

        // --- CRUD Operations ---

        // Add a new node
        async function addNode(nodeData) {
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(nodeData)
                });
                if (!response.ok) {
                    throw new Error('Failed to add node');
                }
                await fetchAndRenderNodes();
            } catch (error) {
                console.error("Error adding node:", error);
            }
        }

        // Update a node
        async function updateNode(nodeId, nodeData) {
            try {
                const response = await fetch(`${API_URL}/${nodeId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(nodeData)
                });
                if (!response.ok) {
                    throw new Error('Failed to update node');
                }
                await fetchAndRenderNodes();
            } catch (error) {
                console.error("Error updating node:", error);
            }
        }

        // Delete a node
        async function deleteNode(nodeId) {
            const confirmed = await showCustomConfirm('你确定要删除这个节点吗？');
            if (!confirmed) {
                return;
            }
            try {
                const response = await fetch(`${API_URL}/${nodeId}`, {
                    method: 'DELETE'
                });
                if (!response.ok) {
                    throw new Error('Failed to delete node');
                }
                await fetchAndRenderNodes();
            } catch (error) {
                console.error("Error deleting node:", error);
            }
        }

        // Get node data for editing
        async function getNodeData(nodeId) {
            try {
                const response = await fetch(`${API_URL}/${nodeId}`);
                if (!response.ok) {
                    throw new Error('Node data not found');
                }
                return await response.json();
            } catch (error) {
                console.error(error);
                return null;
            }
        }

        // --- Modal Handling ---

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
            editingNodeId = null;
        }

        function openAddModal() {
            const modal = document.getElementById('node-modal');
            document.getElementById('modal-title').textContent = '增加新节点';
            document.getElementById('node-form').reset();
            
            // Randomly select a darker color
            const randomColor = macaronColors[Math.floor(Math.random() * macaronColors.length)];
            document.getElementById('color').value = randomColor;

            editingNodeId = null;
            modal.classList.add('active');
        }

        async function openEditModal(nodeId) {
            const modal = document.getElementById('node-modal');
            const node = await getNodeData(nodeId);
            if (!node) {
                await showCustomConfirm('该节点为示例数据，无法编辑。请先添加自己的节点。');
                return;
            }

            document.getElementById('modal-title').textContent = '修改节点';
            document.getElementById('title').value = node.title;
            document.getElementById('content').value = node.content;
            document.getElementById('color').value = node.color;
            editingNodeId = nodeId;

            modal.classList.add('active');
        }

        async function fetchHeaderFooterData() {
            try {
                const response = await fetch('/api/header_footer');
                if (!response.ok) return { header: {}, footer: {} };
                return await response.json();
            } catch (e) {
                return { header: {}, footer: {} };
            }
        }

        async function fetchAndRenderHeaderFooter() {
            const data = await fetchHeaderFooterData();
            if (data.header) {
                document.getElementById('main-title').textContent = data.header.main_title || '';
                document.getElementById('subtitle').textContent = data.header.subtitle || '';
            }
            if (data.footer) {
                document.getElementById('footer-text').textContent = data.footer.footer_text || '';
            }
        }

        function openHeaderModal() {
            const modal = document.getElementById('header-modal');
            document.getElementById('modal-main-title').value = document.getElementById('main-title').textContent;
            document.getElementById('modal-subtitle').value = document.getElementById('subtitle').textContent;
            modal.classList.add('active');
        }

        function openFooterModal() {
            const modal = document.getElementById('footer-modal');
            document.getElementById('modal-footer-text').value = document.getElementById('footer-text').textContent;
            modal.classList.add('active');
        }
        
        // --- Image Cropping and Handling ---

        function cropImageAndGetBase64(file, callback) {
            // 新实现：弹出裁剪弹窗，用户拖拽后裁剪
            const reader = new FileReader();
            reader.onload = (e) => {
                const cropperModal = document.getElementById('cropper-modal');
                const cropperImg = document.getElementById('cropper-image');
                cropperImg.src = e.target.result;
                cropperModal.classList.add('active');

                let cropper = null;
                // 等图片加载后初始化 cropper
                cropperImg.onload = () => {
                    if (cropper) cropper.destroy();
                    cropper = new Cropper(cropperImg, {
                        aspectRatio: 1,
                        viewMode: 1,
                        dragMode: 'move',
                        autoCropArea: 1,
                        background: false,
                        movable: true,
                        zoomable: true,
                        rotatable: false,
                        scalable: false,
                        minCropBoxWidth: 100,
                        minCropBoxHeight: 100
                    });
                };

                // 取消按钮
                document.getElementById('cropper-cancel').onclick = () => {
                    cropperModal.classList.remove('active');
                    if (cropper) cropper.destroy();
                };
                // 确定按钮
                document.getElementById('cropper-confirm').onclick = () => {
                    // 获取裁剪区域
                    const canvas = cropper.getCroppedCanvas({ width: 200, height: 200, imageSmoothingQuality: 'high' });
                    // 生成圆形头像
                    const circleCanvas = document.createElement('canvas');
                    circleCanvas.width = 200;
                    circleCanvas.height = 200;
                    const ctx = circleCanvas.getContext('2d');
                    ctx.clearRect(0, 0, 200, 200);
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(100, 100, 100, 0, 2 * Math.PI);
                    ctx.closePath();
                    ctx.clip();
                    ctx.drawImage(canvas, 0, 0, 200, 200);
                    ctx.restore();
                    cropperModal.classList.remove('active');
                    if (cropper) cropper.destroy();
                    callback(circleCanvas.toDataURL('image/png'));
                };
            };
            reader.readAsDataURL(file);
        }

        // --- Event Listeners ---

        // Handle form submission for adding/editing nodes
        document.getElementById('node-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            const nodeData = {
                title: formData.get('title'),
                content: formData.get('content'),
                color: formData.get('color')
            };

            const imageFile = formData.get('imageUpload');
            if (imageFile && imageFile.size > 0) {
                // 先读取原图 base64
                const reader = new FileReader();
                reader.onload = (e) => {
                    const originalBase64 = e.target.result;
                    // 再裁剪头像
                    cropImageAndGetBase64(imageFile, async (avatarBase64) => {
                        nodeData.original_image_base64 = originalBase64;
                        nodeData.avatar_image_base64 = avatarBase64;
                        if (editingNodeId) {
                            await updateNode(editingNodeId, nodeData);
                        } else {
                            await addNode(nodeData);
                        }
                        closeModal('node-modal');
                    });
                };
                reader.readAsDataURL(imageFile);
            } else {
                if (editingNodeId) {
                    // If no new image,不传base64，后端保留原有图片
                    await updateNode(editingNodeId, nodeData);
                } else {
                    await addNode(nodeData);
                }
                closeModal('node-modal');
            }
        });

        // Handle form submission for editing header
        document.getElementById('header-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const data = await fetchHeaderFooterData();
            const mainTitle = document.getElementById('modal-main-title').value;
            const subtitle = document.getElementById('modal-subtitle').value;
            const payload = {
                header: { main_title: mainTitle, subtitle: subtitle },
                footer: data.footer
            };
            try {
                await fetch('/api/header_footer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                await fetchAndRenderHeaderFooter();
            } catch (err) { /* ignore */ }
            closeModal('header-modal');
        });

        // Handle form submission for editing footer
        document.getElementById('footer-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const data = await fetchHeaderFooterData();
            const footerText = document.getElementById('modal-footer-text').value;
            const payload = {
                header: data.header,
                footer: { footer_text: footerText }
            };
            try {
                await fetch('/api/header_footer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                await fetchAndRenderHeaderFooter();
            } catch (err) { /* ignore */ }
            closeModal('footer-modal');
        });
        

        // Re-render connectors on window resize
        window.addEventListener('resize', () => {
            setTimeout(() => renderConnectors(nodesData), 100);
        });

        // Initial fetches on page load
        document.addEventListener('DOMContentLoaded', () => {
            fetchAndRenderHeaderFooter();
            fetchAndRenderNodes();
            setupConnectorObservers();
            // Extra redraw after 500ms for mobile scaling quirks
            setTimeout(() => renderConnectors(nodesData), 500);
        });
    </script>

</body>
</html>
